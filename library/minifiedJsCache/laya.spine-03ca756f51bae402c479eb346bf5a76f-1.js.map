{"version":3,"names":["ExternalSkin","source","this","_source","value","ILaya","loader","load","Loader","SPINE","then","templet","isCreateFromURL","items","_items","_templet","init","flush","target","skeletonData","_textures","i","length","o","attachmentStr","attachment","slot","skinStr","skin","skins","j","name","attachments","regionPage","region","page","texture","slotObj","getSkeleton","findSlot","setAttachment","ExternalSkinItem","_skin","_slot","_attachment","QUAD_TRIANGLES","SpineSkeletonRenderer","constructor","twoColorTint","vertexEffect","tempColor","spine","Color","tempColor2","vertexSize","temp","Vector2","temp2","temp3","temp4","vertices","ns","Utils","newFloatArray","renderable","numVertices","numFloats","clipper","SkeletonClipping","draw","skeleton","graphics","slotRangeStart","slotRangeEnd","premultipliedAlpha","tempPos","tempUv","tempLight","tempDark","uvs","triangles","drawOrder","attachmentColor","skeletonColor","color","inRange","n","clippedVertexSize","isClipping","data","index","clipEndWithSlot","getAttachment","RegionAttachment","computeWorldVertices","bone","renderObject","getTexture","MeshAttachment","ClippingAttachment","clip","clipStart","mesh","worldVerticesLength","slotColor","finalColor","r","g","b","a","slotBlendMode","blendMode","clipTriangles","clippedVertices","Float32Array","clippedTriangles","mVertices","mUVs","colorNum","alpha","verts","v","x","y","set","transform","push","vi","Number","isFinite","drawTriangles","realTexture","Uint16Array","Matrix","EMPTY","u","setFromColor","clipEnd","SpineSkeleton","Sprite","super","_currentPlayTime","_pause","_currAniName","_playbackRate","_playAudio","_soundChannelArr","trackIndex","_skinName","_animationName","_loop","externalSkins","_externalSkins","resetExternalSkin","_skeleton","Skeleton","_flushExtSkin","skinName","showSkinByName","animationName","play","loop","currentTime","_playStart","_playEnd","_duration","Error","_state","update","playState","PAUSED","PLAYING","STOPPED","reset","clear","_addReference","_stateData","AnimationStateData","AnimationState","_renerer","_timeKeeper","TimeKeeper","skinIndex","getSkinIndexByName","showSkinByIndex","addListener","start","entry","interrupt","end","dispose","complete","event","Event","COMPLETE","eventData","audioValue","audioPath","floatValue","intValue","stringValue","time","balance","volume","LABEL","channel","SoundManager","playSound","basePath","Handler","create","_onAniSoundStoped","playbackRate","READY","LayaEnv","isPlaying","nameOrIndex","force","freshSkin","playAudio","getAniNameByIndex","setAnimation","trackEntry","getCurrent","animationStart","animationEnd","animationDuration","animation","duration","timer","frameLoop","_update","delta","apply","animationLast","Math","max","updateWorldTransform","getAnimNum","animations","getSlotByName","slotName","newSkine","setSkin","setSlotsToSetupPose","stop","paused","len","isStopped","pause","resume","audioBuffer","splice","_removeReference","clearListeners","destroy","destroyChild","addAnimation","delay","setMix","fromNameOrIndex","toNameOrIndex","fromName","toName","getBoneByName","boneName","findBone","setSlotAttachment","attachmentName","SpineTexture","tex","getImage","width","_b","_a","sourceWidth","height","_d","_c","sourceHeight","setFilters","minFilter","magFilter","filterMode","TextureFilter","Nearest","FilterMode","Point","Bilinear","bitmap","convertWrapMode","mode","TextureWrap","ClampToEdge","WrapMode","Clamp","MirroredRepeat","Mirrored","Repeat","setWraps","uWrap","vWrap","tex2D","wrapModeU","wrapModeV","SpineTemplet","Resource","_ns","_basePath","_parse","desc","atlasText","createURL","progress","parseAtlas","URL","getPath","getRuntimeVersion","parseAtlas4","parseAtlas3","call","atlas","atlasLoader","AtlasAttachmentLoader","ArrayBuffer","skeletonBinary","SkeletonBinary","readSkeletonData","Uint8Array","skeletonJson","SkeletonJson","RuntimeVersion","atlasPages","TextureAtlas","path","url","createCallback","res","spineTex","pages","map","setTexture","tAni","tSkinData","_disposeResource","k","registerLoader","task","atlasUrl","replaceFileExtension","Promise","all","fetch","ext","c","ClassUtils","regClass"],"sources":["../../src/layaAir/laya/spine/ExternalSkin.ts","../../src/layaAir/laya/spine/ExternalSkinItem.ts","../../src/layaAir/laya/spine/SpineSkeletonRenderer.ts","../../src/layaAir/laya/spine/SpineSkeleton.ts","../../src/layaAir/laya/spine/SpineTexture.ts","../../src/layaAir/laya/spine/SpineTemplet.ts","../../src/layaAir/laya/spine/SpineTempletLoader.ts","../../src/layaAir/laya/spine/ModuleDef.ts"],"sourcesContent":["import { ILaya } from \"../../ILaya\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nexport class ExternalSkin {\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _items: ExternalSkinItem[];\r\n    target: SpineSkeleton;\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    set items(value: ExternalSkinItem[]) {\r\n        this._items = value;\r\n    }\r\n    get items() {\r\n        return this._items;\r\n    }\r\n\r\n\r\n    /**\r\n    * 得到动画模板的引用\r\n    * @return templet\r\n    */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n    protected init(templet: SpineTemplet): void {\r\n        this._templet = templet;\r\n        if (!this._templet) {\r\n            return;\r\n        }\r\n        this.flush();\r\n    }\r\n    flush() {\r\n        if (this.target && this.target.templet && this._items && this._templet && this._templet.skeletonData) {\r\n            if (null == (this.target.templet as any)._textures) return;\r\n            for (let i = this._items.length - 1; i >= 0; i--) {\r\n                let o = this._items[i];\r\n                let attachmentStr = o.attachment;\r\n                let slot = o.slot;\r\n                let skinStr = o.skin;\r\n\r\n                if (attachmentStr && slot && skinStr) {\r\n                    let attachment: spine.Attachment = null;\r\n                    let skins = this._templet.skeletonData.skins;\r\n                    for (let j = skins.length - 1; j >= 0; j--) {\r\n                        if (skins[j].name == skinStr) {\r\n                            let skin = skins[j];\r\n                            let attachments = skin.attachments;\r\n                            for (let j = attachments.length - 1; j >= 0; j--) {\r\n                                attachment = attachments[j][attachmentStr];\r\n                                if (attachment) {\r\n                                    break;\r\n                                }\r\n                            }\r\n                            break;\r\n                        }\r\n                    }\r\n                    if (attachment) {\r\n                        let regionPage = (attachment as any).region.page;\r\n                        (this.target.templet as any)._textures[regionPage.name] = regionPage.texture;\r\n                        let slotObj = this.target.getSkeleton().findSlot(slot);\r\n                        if (slotObj) {\r\n                            slotObj.setAttachment(attachment);\r\n                        }\r\n                    }\r\n                }\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n}","export class ExternalSkinItem {\r\n    protected _skin: string;\r\n    protected _slot: string;\r\n    protected _attachment: string;\r\n\r\n    get skin() {\r\n        return this._skin;\r\n    }\r\n    set skin(value: string) {\r\n        this._skin = value;\r\n    }\r\n    set slot(value: string) {\r\n        this._slot = value;\r\n    }\r\n    get slot() {\r\n        return this._slot;\r\n    }\r\n    set attachment(value: string) {\r\n        this._attachment = value;\r\n    }\r\n    get attachment() {\r\n        return this._attachment;\r\n    }\r\n\r\n}","import { Graphics } from \"../display/Graphics\";\r\nimport { Matrix } from \"../maths/Matrix\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\ninterface Renderable {\r\n    vertices: spine.ArrayLike<number>;\r\n    numVertices: number;\r\n    numFloats: number;\r\n}\r\n\r\nconst QUAD_TRIANGLES = [0, 1, 2, 2, 3, 0];\r\n\r\nexport class SpineSkeletonRenderer {\r\n    premultipliedAlpha: boolean;\r\n    vertexEffect: spine.VertexEffect = null;\r\n    templet: SpineTemplet;\r\n\r\n    private tempColor = new spine.Color();\r\n    private tempColor2 = new spine.Color();\r\n    private vertices: ArrayLike<number>;\r\n    private vertexSize = 2 + 2 + 4;\r\n    private twoColorTint = false;\r\n    private renderable: Renderable;\r\n    private clipper: spine.SkeletonClipping;\r\n    private temp = new spine.Vector2();\r\n    private temp2 = new spine.Vector2();\r\n    private temp3 = new spine.Color();\r\n    private temp4 = new spine.Color();\r\n\r\n    constructor(templet: SpineTemplet, twoColorTint: boolean = true) {\r\n        this.twoColorTint = twoColorTint;\r\n        if (twoColorTint)\r\n            this.vertexSize += 4;\r\n        this.templet = templet;\r\n        this.vertices = templet.ns.Utils.newFloatArray(this.vertexSize * 1024);\r\n        this.renderable = { vertices: null, numVertices: 0, numFloats: 0 };\r\n        this.clipper = new templet.ns.SkeletonClipping();\r\n    }\r\n\r\n    draw(skeleton: spine.Skeleton, graphics: Graphics, slotRangeStart: number = -1, slotRangeEnd: number = -1) {\r\n        let clipper = this.clipper;\r\n        let premultipliedAlpha = this.premultipliedAlpha;\r\n        let twoColorTint = false;\r\n        let blendMode: spine.BlendMode = null;\r\n\r\n        let tempPos = this.temp;\r\n        let tempUv = this.temp2;\r\n        let tempLight = this.temp3;\r\n        let tempDark = this.temp4;\r\n\r\n        let renderable: Renderable = this.renderable;\r\n        let uvs: ArrayLike<number> = null;\r\n        let triangles: Array<number> = null;\r\n        let drawOrder = skeleton.drawOrder;\r\n        let attachmentColor: spine.Color = null;\r\n        let skeletonColor = skeleton.color;\r\n        let vertexSize = twoColorTint ? 12 : 8;\r\n        let inRange = false;\r\n\r\n        if (slotRangeStart == -1) inRange = true;\r\n        for (let i = 0, n = drawOrder.length; i < n; i++) {\r\n            let clippedVertexSize = clipper.isClipping() ? 2 : vertexSize;\r\n            let slot = drawOrder[i];\r\n\r\n            if (slotRangeStart >= 0 && slotRangeStart == slot.data.index) {\r\n                inRange = true;\r\n            }\r\n\r\n            if (!inRange) {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (slotRangeEnd >= 0 && slotRangeEnd == slot.data.index) {\r\n                inRange = false;\r\n            }\r\n\r\n            let attachment = slot.getAttachment();\r\n            let name: string = null;\r\n            let texture: SpineTexture;\r\n            if (attachment instanceof this.templet.ns.RegionAttachment) {\r\n                let region = <spine.RegionAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = 4;\r\n                renderable.numFloats = clippedVertexSize << 2;\r\n                region.computeWorldVertices(slot.bone, renderable.vertices, 0, clippedVertexSize);\r\n                triangles = QUAD_TRIANGLES;\r\n                uvs = region.uvs;\r\n                name = region.region.renderObject.page.name;\r\n                texture = this.templet.getTexture(name);\r\n                attachmentColor = region.color;\r\n            } else if (attachment instanceof this.templet.ns.MeshAttachment) {\r\n                let mesh = <spine.MeshAttachment>attachment;\r\n                renderable.vertices = this.vertices;\r\n                renderable.numVertices = (mesh.worldVerticesLength >> 1);\r\n                renderable.numFloats = renderable.numVertices * clippedVertexSize;\r\n                if (renderable.numFloats > renderable.vertices.length) {\r\n                    renderable.vertices = this.vertices = this.templet.ns.Utils.newFloatArray(renderable.numFloats);\r\n                }\r\n                mesh.computeWorldVertices(slot, 0, mesh.worldVerticesLength, renderable.vertices, 0, clippedVertexSize);\r\n                triangles = mesh.triangles;\r\n                name = mesh.region.renderObject.page.name\r\n                texture = this.templet.getTexture(name);\r\n                uvs = mesh.uvs;\r\n                attachmentColor = mesh.color;\r\n            } else if (attachment instanceof this.templet.ns.ClippingAttachment) {\r\n                let clip = <spine.ClippingAttachment>(attachment);\r\n                clipper.clipStart(slot, clip);\r\n                continue;\r\n            } else {\r\n                clipper.clipEndWithSlot(slot);\r\n                continue;\r\n            }\r\n\r\n            if (texture != null) {\r\n                let slotColor = slot.color;\r\n                let finalColor = this.tempColor;\r\n                finalColor.r = skeletonColor.r * slotColor.r * attachmentColor.r;\r\n                finalColor.g = skeletonColor.g * slotColor.g * attachmentColor.g;\r\n                finalColor.b = skeletonColor.b * slotColor.b * attachmentColor.b;\r\n                finalColor.a = skeletonColor.a * slotColor.a * attachmentColor.a;\r\n                if (premultipliedAlpha) {\r\n                    finalColor.r *= finalColor.a;\r\n                    finalColor.g *= finalColor.a;\r\n                    finalColor.b *= finalColor.a;\r\n                }\r\n\r\n                let slotBlendMode = slot.data.blendMode;\r\n                if (slotBlendMode != blendMode) {\r\n                    blendMode = slotBlendMode;\r\n                }\r\n\r\n                if (clipper.isClipping()) {\r\n                    clipper.clipTriangles(renderable.vertices, renderable.numFloats, triangles, triangles.length, uvs, finalColor, null, twoColorTint);\r\n                    let clippedVertices = new Float32Array(clipper.clippedVertices);\r\n                    let clippedTriangles = clipper.clippedTriangles;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        let verts = clippedVertices;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, n = clippedVertices.length; v < n; v += vertexSize) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempLight.set(verts[v + 2], verts[v + 3], verts[v + 4], verts[v + 5]);\r\n                                tempUv.x = verts[v + 6];\r\n                                tempUv.y = verts[v + 7];\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4];\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        let vi = 0;\r\n                        while (Number.isFinite(clippedVertices[vi + 6]) && Number.isFinite(clippedVertices[vi + 7])) {\r\n                            mVertices.push(clippedVertices[vi]);\r\n                            mVertices.push(-clippedVertices[vi + 1]);\r\n                            colorNum = (clippedVertices[vi + 2] * 255 << 16) + (clippedVertices[vi + 3] * 255 << 8) + clippedVertices[vi + 4] * 255;\r\n                            alpha = clippedVertices[vi + 5];\r\n                            mUVs.push(clippedVertices[vi + 6]);\r\n                            mUVs.push(clippedVertices[vi + 7]);\r\n                            vi += this.vertexSize;\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(clippedTriangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                } else {\r\n                    let verts = renderable.vertices;\r\n                    let mVertices = [];\r\n                    let mUVs = [];\r\n                    let colorNum = 0xffffff;\r\n                    let alpha = 1;\r\n                    if (this.vertexEffect != null) {\r\n                        let vertexEffect = this.vertexEffect;\r\n                        if (!twoColorTint) {\r\n                            for (let v = 0, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                tempPos.x = verts[v];\r\n                                tempPos.y = verts[v + 1];\r\n                                tempUv.x = uvs[u];\r\n                                tempUv.y = uvs[u + 1]\r\n                                tempLight.setFromColor(finalColor);\r\n                                tempDark.set(0, 0, 0, 0);\r\n                                vertexEffect.transform(tempPos, tempUv, tempLight, tempDark);\r\n                                verts[v] = tempPos.x;\r\n                                verts[v + 1] = tempPos.y;\r\n                                verts[v + 2] = tempLight.r;\r\n                                verts[v + 3] = tempLight.g;\r\n                                verts[v + 4] = tempLight.b;\r\n                                verts[v + 5] = tempLight.a;\r\n                                verts[v + 6] = tempUv.x;\r\n                                verts[v + 7] = tempUv.y\r\n\r\n                                mVertices.push(verts[v], -verts[v + 1]);\r\n                                colorNum = (verts[v + 2] * 255 << 16) + (verts[v + 3] * 255 << 8) + verts[v + 4] * 255;\r\n                                alpha = verts[v + 5];\r\n                                mUVs.push(verts[v + 6], verts[v + 7]);\r\n                            }\r\n                        }\r\n                    } else {\r\n                        if (!twoColorTint) {\r\n                            for (let v = 2, u = 0, n = renderable.numFloats; v < n; v += vertexSize, u += 2) {\r\n                                verts[v] = finalColor.r;\r\n                                verts[v + 1] = finalColor.g;\r\n                                verts[v + 2] = finalColor.b;\r\n                                verts[v + 3] = finalColor.a;\r\n                                verts[v + 4] = uvs[u];\r\n                                verts[v + 5] = uvs[u + 1];\r\n\r\n                                mVertices.push(verts[v - 2], -verts[v - 1]);\r\n                                colorNum = (verts[v] * 255 << 16) + (verts[v + 1] * 255 << 8) + verts[v + 2] * 255;\r\n                                alpha = verts[v + 3];\r\n                                mUVs.push(verts[v + 4], verts[v + 5]);\r\n                            }\r\n                        }\r\n                    }\r\n                    let blendMode;\r\n                    switch (slotBlendMode) {\r\n                        case 1:\r\n                            blendMode = \"light\";\r\n                            break;\r\n                        case 2:\r\n                            blendMode = \"multiply\";\r\n                            break;\r\n                        case 3:\r\n                            blendMode = \"screen\";\r\n                            break;\r\n                        default:\r\n                            blendMode = \"normal\";\r\n                    }\r\n                    graphics.drawTriangles(texture.realTexture, 0, 0, <any>mVertices, <any>mUVs, new Uint16Array(triangles), Matrix.EMPTY, alpha, colorNum, blendMode);\r\n                }\r\n            }\r\n\r\n            clipper.clipEndWithSlot(slot);\r\n        }\r\n        clipper.clipEnd();\r\n    }\r\n}\r\n","import { ILaya } from \"../../ILaya\";\r\nimport { LayaEnv } from \"../../LayaEnv\";\r\nimport { Sprite } from \"../display/Sprite\";\r\nimport { Event } from \"../events/Event\";\r\nimport { SoundChannel } from \"../media/SoundChannel\";\r\nimport { SoundManager } from \"../media/SoundManager\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Handler } from \"../utils/Handler\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { SpineSkeletonRenderer } from \"./SpineSkeletonRenderer\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\n/**动画开始播放调度\r\n * @eventType Event.PLAYED\r\n * */\r\n/*[Event(name = \"played\", type = \"laya.events.Event.PLAYED\", desc = \"动画开始播放调度\")]*/\r\n/**动画停止播放调度\r\n * @eventType Event.STOPPED\r\n * */\r\n/*[Event(name = \"stopped\", type = \"laya.events.Event.STOPPED\", desc = \"动画停止播放调度\")]*/\r\n/**动画暂停播放调度\r\n * @eventType Event.PAUSED\r\n * */\r\n/*[Event(name = \"paused\", type = \"laya.events.Event.PAUSED\", desc = \"动画暂停播放调度\")]*/\r\n/**自定义事件。\r\n * @eventType Event.LABEL\r\n */\r\n/*[Event(name = \"label\", type = \"laya.events.Event.LABEL\", desc = \"自定义事件\")]*/\r\n/**\r\n * spine动画由<code>SpineTemplet</code>，<code>SpineSkeletonRender</code>，<code>SpineSkeleton</code>三部分组成。\r\n */\r\nexport class SpineSkeleton extends Sprite {\r\n    static readonly STOPPED: number = 0;\r\n    static readonly PAUSED: number = 1;\r\n    static readonly PLAYING: number = 2;\r\n\r\n    protected _source: string;\r\n    protected _templet: SpineTemplet;\r\n    protected _timeKeeper: spine.TimeKeeper;\r\n    protected _skeleton: spine.Skeleton;\r\n    protected _state: spine.AnimationState;\r\n    protected _stateData: spine.AnimationStateData;\r\n    protected _currentPlayTime: number = 0;\r\n    protected _renerer: SpineSkeletonRenderer;\r\n\r\n    /** @internal */\r\n    private _pause: boolean = true;\r\n    /** @internal */\r\n    private _currAniName: string = null;\r\n    /** @internal 动画播放的起始时间位置*/\r\n    private _playStart: number;\r\n    /** @internal 动画播放的结束时间位置*/\r\n    private _playEnd: number;\r\n    /** @internal 动画的总时间*/\r\n    private _duration: number;\r\n    /** 播放速率*/\r\n    private _playbackRate: number = 1.0;\r\n    /** @internal */\r\n    private _playAudio: boolean = true;\r\n    /** @internal */\r\n    private _soundChannelArr: any[] = [];\r\n    // 播放轨道索引\r\n    private trackIndex: number = 0;\r\n\r\n    private _skinName: string = \"default\";\r\n    private _animationName: string = \"\";\r\n    private _loop: boolean = true;\r\n\r\n    private _externalSkins: ExternalSkin[];\r\n\r\n    constructor() {\r\n        super();\r\n    }\r\n\r\n    get externalSkins() {\r\n        return this._externalSkins;\r\n    }\r\n    set externalSkins(value: ExternalSkin[]) {\r\n        if (value) {\r\n            for (let i = value.length - 1; i >= 0; i--) {\r\n                value[i].target = this;\r\n            }\r\n        }\r\n        this._externalSkins = value;\r\n    }\r\n    /**\r\n     * 重置外部加载的皮肤的样式\r\n     */\r\n    resetExternalSkin() {\r\n        if (this._skeleton) {\r\n            this._skeleton = new this._templet.ns.Skeleton(this._templet.skeletonData);\r\n            this._flushExtSkin();\r\n        }\r\n    }\r\n\r\n    get source(): string {\r\n        return this._source;\r\n    }\r\n\r\n    set source(value: string) {\r\n        this._source = value;\r\n\r\n        if (value) {\r\n            ILaya.loader.load(value, Loader.SPINE).then((templet: SpineTemplet) => {\r\n                if (!this._source || templet && !templet.isCreateFromURL(this._source))\r\n                    return;\r\n\r\n                this.templet = templet;\r\n            });\r\n        }\r\n        else\r\n            this.templet = null;\r\n    }\r\n\r\n    get skinName(): string {\r\n        return this._skinName;\r\n    }\r\n\r\n    set skinName(value: string) {\r\n        this._skinName = value;\r\n        if (this._templet)\r\n            this.showSkinByName(value);\r\n    }\r\n\r\n    get animationName(): string {\r\n        return this._animationName;\r\n    }\r\n\r\n    set animationName(value: string) {\r\n        this._animationName = value;\r\n        if (this._templet)\r\n            this.play(value, this._loop, true);\r\n    }\r\n\r\n    get loop(): boolean {\r\n        return this._loop;\r\n    }\r\n\r\n    set loop(value: boolean) {\r\n        this._loop = value;\r\n        if (this._templet)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 得到动画模板的引用\r\n     * @return templet\r\n     */\r\n    get templet(): SpineTemplet {\r\n        return this._templet;\r\n    }\r\n\r\n    /**\r\n     * \r\n     */\r\n    set templet(value: SpineTemplet) {\r\n        this.init(value);\r\n    }\r\n\r\n    /**\r\n     * 设置当前播放位置\r\n     * @param\tvalue 当前时间\r\n     */\r\n    set currentTime(value: number) {\r\n        if (!this._currAniName || !this._templet)\r\n            return;\r\n\r\n        value /= 1000;\r\n        if (value < this._playStart || (!!this._playEnd && value > this._playEnd) || value > this._duration)\r\n            throw new Error(\"AnimationPlayer: value must large than playStartTime,small than playEndTime.\");\r\n\r\n        this._state.update(value - this._currentPlayTime);\r\n        this._currentPlayTime = value;\r\n    }\r\n\r\n    /**\r\n     * 获取当前播放状态\r\n     * @return\t当前播放状态\r\n     */\r\n    get playState(): number {\r\n        if (!this._currAniName)\r\n            return SpineSkeleton.STOPPED;\r\n        if (this._pause)\r\n            return SpineSkeleton.PAUSED;\r\n        return SpineSkeleton.PLAYING;\r\n    }\r\n\r\n    protected init(templet: SpineTemplet): void {\r\n        if (this._templet) {\r\n            this.reset();\r\n            this.graphics.clear();\r\n        }\r\n\r\n        this._templet = templet;\r\n        if (!this._templet)\r\n            return;\r\n\r\n        this._templet._addReference();\r\n        this._skeleton = new templet.ns.Skeleton(this._templet.skeletonData);\r\n        this._stateData = new templet.ns.AnimationStateData(this._skeleton.data);\r\n        // 动画状态类\r\n        this._state = new templet.ns.AnimationState(this._stateData);\r\n        this._renerer = new SpineSkeletonRenderer(templet, false);\r\n        this._timeKeeper = new templet.ns.TimeKeeper();\r\n\r\n        let skinIndex = this._templet.getSkinIndexByName(this._skinName);\r\n        if (skinIndex != -1)\r\n            this.showSkinByIndex(skinIndex);\r\n\r\n        this._state.addListener({\r\n            start: (entry: any) => {\r\n                // console.log(\"started:\", entry);\r\n            },\r\n            interrupt: (entry: any) => {\r\n                // console.log(\"interrupt:\", entry);\r\n            },\r\n            end: (entry: any) => {\r\n                // console.log(\"end:\", entry);\r\n            },\r\n            dispose: (entry: any) => {\r\n                // console.log(\"dispose:\", entry);\r\n            },\r\n            complete: (entry: any) => {\r\n                // console.log(\"complete:\", entry);\r\n                if (entry.loop) { // 如果多次播放,发送complete事件\r\n                    this.event(Event.COMPLETE);\r\n                } else { // 如果只播放一次，就发送stop事件\r\n                    this._currAniName = null;\r\n                    this.event(Event.STOPPED);\r\n                }\r\n            },\r\n            event: (entry: any, event: any) => {\r\n                let eventData = {\r\n                    audioValue: event.data.audioPath,\r\n                    audioPath: event.data.audioPath,\r\n                    floatValue: event.floatValue,\r\n                    intValue: event.intValue,\r\n                    name: event.data.name,\r\n                    stringValue: event.stringValue,\r\n                    time: event.time * 1000,\r\n                    balance: event.balance,\r\n                    volume: event.volume\r\n                };\r\n                // console.log(\"event:\", entry, event);\r\n                this.event(Event.LABEL, eventData);\r\n                if (this._playAudio && eventData.audioValue) {\r\n                    let channel = SoundManager.playSound(templet.basePath + eventData.audioValue, 1, Handler.create(this, this._onAniSoundStoped), null, (this._currentPlayTime * 1000 - eventData.time) / 1000);\r\n                    SoundManager.playbackRate = this._playbackRate;\r\n                    channel && this._soundChannelArr.push(channel);\r\n                }\r\n            },\r\n        });\r\n        this._flushExtSkin();\r\n        this.event(Event.READY);\r\n\r\n        if (LayaEnv.isPlaying && this._animationName)\r\n            this.play(this._animationName, this._loop, true);\r\n    }\r\n\r\n    /**\r\n     * 播放动画\r\n     *\r\n     * @param\tnameOrIndex\t动画名字或者索引\r\n     * @param\tloop\t\t是否循环播放\r\n     * @param\tforce\t\tfalse,如果要播的动画跟上一个相同就不生效,true,强制生效\r\n     * @param\tstart\t\t起始时间\r\n     * @param\tend\t\t\t结束时间\r\n     * @param\tfreshSkin\t是否刷新皮肤数据\r\n     * @param\tplayAudio\t是否播放音频\r\n     */\r\n    play(nameOrIndex: any, loop: boolean, force: boolean = true, start: number = 0, end: number = 0, freshSkin: boolean = true, playAudio: boolean = true) {\r\n        this._playAudio = playAudio;\r\n        start /= 1000;\r\n        end /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (start < 0 || end < 0)\r\n            throw new Error(\"SpineSkeleton: start and end must large than zero.\");\r\n        if ((end !== 0) && (start > end))\r\n            throw new Error(\"SpineSkeleton: start must less than end.\");\r\n\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(nameOrIndex);\r\n        }\r\n\r\n        if (force || this._pause || this._currAniName != animationName) {\r\n            this._currAniName = animationName;\r\n            // 设置执行哪个动画\r\n            this._state.setAnimation(this.trackIndex, animationName, loop);\r\n            // 设置起始和结束时间\r\n            let trackEntry = this._state.getCurrent(this.trackIndex);\r\n            trackEntry.animationStart = start;\r\n            if (!!end && end < trackEntry.animationEnd)\r\n                trackEntry.animationEnd = end;\r\n\r\n            let animationDuration = trackEntry.animation.duration;\r\n            this._duration = animationDuration;\r\n            this._playStart = start;\r\n            this._playEnd = end <= animationDuration ? end : animationDuration;\r\n\r\n            if (this._pause) {\r\n                this._pause = false;\r\n                this.timer.frameLoop(1, this, this._update, null, true);\r\n            }\r\n            this._update();\r\n        }\r\n    }\r\n\r\n    private _update(): void {\r\n        this._timeKeeper.update();\r\n        let delta = this._timeKeeper.delta * this._playbackRate;\r\n        let trackEntry = this._state.getCurrent(this.trackIndex);\r\n        // 在游戏循环中，update被调用，这样AnimationState就可以跟踪时间\r\n        this._state.update(delta);\r\n        // 使用当前动画和事件设置骨架\r\n        this._state.apply(this._skeleton);\r\n\r\n        let animationLast = trackEntry.animationLast;\r\n        this._currentPlayTime = Math.max(0, animationLast);\r\n\r\n        // spine在state.apply中发送事件，开发者可能会在事件中进行destory等操作，导致无法继续执行\r\n        if (!this._state || !this._skeleton) {\r\n            return;\r\n        }\r\n        // 计算骨骼的世界SRT(world SRT)\r\n        this._skeleton.updateWorldTransform();\r\n\r\n        this.graphics.clear();\r\n        this._renerer.draw(this._skeleton, this.graphics, -1, -1);\r\n    }\r\n\r\n    private _flushExtSkin() {\r\n        if (null == this._skeleton) return;\r\n        let skins = this._externalSkins;\r\n        if (skins) {\r\n            for (let i = skins.length - 1; i >= 0; i--) {\r\n                skins[i].flush();\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * 得到当前动画的数量\r\n     * @return 当前动画的数量\r\n     */\r\n    getAnimNum(): number {\r\n        return this._templet.skeletonData.animations.length;\r\n    }\r\n\r\n    /**\r\n     * 得到指定动画的名字\r\n     * @param\tindex\t动画的索引\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        return this._templet.getAniNameByIndex(index);\r\n    }\r\n\r\n    /**\r\n     * 通过名字得到插槽的引用\r\n     * @param slotName \r\n     */\r\n    getSlotByName(slotName: string) {\r\n        return this._skeleton.findSlot(slotName)\r\n    }\r\n\r\n    /**\r\n     * 设置动画播放速率\r\n     * @param\tvalue\t1为标准速率\r\n     */\r\n    playbackRate(value: number): void {\r\n        this._playbackRate = value;\r\n    }\r\n\r\n    /**\r\n     * 通过名字显示一套皮肤\r\n     * @param\tname\t皮肤的名字\r\n     */\r\n    showSkinByName(name: string): void {\r\n        this.showSkinByIndex(this._templet.getSkinIndexByName(name));\r\n    }\r\n\r\n    /**\r\n     * 通过索引显示一套皮肤\r\n     * @param\tskinIndex\t皮肤索引\r\n     */\r\n    showSkinByIndex(skinIndex: number): void {\r\n        let newSkine = this._skeleton.data.skins[skinIndex];\r\n        this._skeleton.setSkin(newSkine);\r\n        this._skeleton.setSlotsToSetupPose();\r\n    }\r\n\r\n    /**\r\n     * 停止动画\r\n     */\r\n    stop(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this._currAniName = null;\r\n            this.timer.clear(this, this._update);\r\n            this._state.update(-this._currentPlayTime);\r\n            this._currentPlayTime = 0;\r\n            this.event(Event.STOPPED);\r\n\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                this._onAniSoundStoped(true);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 暂停动画的播放\r\n     */\r\n    paused(): void {\r\n        if (!this._pause) {\r\n            this._pause = true;\r\n            this.timer.clear(this, this._update);\r\n            this.event(Event.PAUSED);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if (!channel.isStopped) {\r\n                        channel.pause();\r\n                    }\r\n\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 恢复动画的播放\r\n     */\r\n    resume(): void {\r\n        if (this._pause) {\r\n            this._pause = false;\r\n            this.timer.frameLoop(1, this, this._update, null, true);\r\n            if (this._soundChannelArr.length > 0) { // 有正在播放的声音\r\n                for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n                    let channel = this._soundChannelArr[i];\r\n                    if ((channel as any).audioBuffer) {\r\n                        channel.resume();\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 清掉播放完成的音频\r\n     * @param force 是否强制删掉所有的声音channel\r\n     */\r\n    private _onAniSoundStoped(force: boolean): void {\r\n        for (let len = this._soundChannelArr.length, i = 0; i < len; i++) {\r\n            let channel = this._soundChannelArr[i];\r\n            if (channel.isStopped || force) {\r\n                !channel.isStopped && channel.stop();\r\n                this._soundChannelArr.splice(i, 1);\r\n                // SoundManager.removeChannel(_channel); // TODO 是否需要? 去掉有什么好处? 是否还需要其他操作?\r\n                len--; i--;\r\n            }\r\n        }\r\n    }\r\n\r\n    private reset() {\r\n        this._templet._removeReference(1);\r\n        this._templet = null;\r\n        this._timeKeeper = null;\r\n        this._skeleton = null;\r\n        this._state.clearListeners();\r\n        this._state = null;\r\n        this._renerer = null;\r\n        this._currAniName = null;\r\n        this._pause = true;\r\n        this.timer.clear(this, this._update);\r\n        if (this._soundChannelArr.length > 0)\r\n            this._onAniSoundStoped(true);\r\n    }\r\n\r\n    /**\r\n     * 销毁当前动画\r\n     * @override\r\n     */\r\n    destroy(destroyChild: boolean = true): void {\r\n        super.destroy(destroyChild);\r\n        if (this._templet)\r\n            this.reset();\r\n    }\r\n\r\n    // ------------------------------------新增加的接口----------------------------------------------------\r\n    /**\r\n     * 添加一个动画\r\n     * @param nameOrIndex   动画名字或者索引\r\n     * @param loop          是否循环播放\r\n     * @param delay         延迟调用，可以为负数\r\n     */\r\n    addAnimation(nameOrIndex: any, loop: boolean = false, delay: number = 0) {\r\n        delay /= 1000;\r\n        let animationName = nameOrIndex;\r\n        if (typeof animationName == \"number\") {\r\n            animationName = this.getAniNameByIndex(animationName);\r\n        }\r\n        this._currAniName = animationName;\r\n        this._state.addAnimation(this.trackIndex, animationName, loop, delay);\r\n    }\r\n\r\n    /**\r\n     * 设置当动画被改变时，存储混合(交叉淡出)的持续时间\r\n     * @param fromNameOrIndex \r\n     * @param toNameOrIndex \r\n     * @param duration\r\n     */\r\n    setMix(fromNameOrIndex: any, toNameOrIndex: any, duration: number) {\r\n        duration /= 1000;\r\n        let fromName = fromNameOrIndex;\r\n        if (typeof fromName == \"number\") {\r\n            fromName = this.getAniNameByIndex(fromName);\r\n        }\r\n        let toName = toNameOrIndex;\r\n        if (typeof toName == \"number\") {\r\n            toName = this.getAniNameByIndex(toName);\r\n        }\r\n        this._stateData.setMix(fromName, toName, duration);\r\n    }\r\n\r\n    /**\r\n     * 获取骨骼信息(spine.Bone)\r\n     * 注意: 获取到的是spine运行时的骨骼信息(spine.Bone)，不适用引擎的方法\r\n     * @param boneName \r\n     */\r\n    getBoneByName(boneName: string) {\r\n        return this._skeleton.findBone(boneName);\r\n    }\r\n\r\n    /**\r\n     * 获取Skeleton(spine.Skeleton)\r\n     */\r\n    getSkeleton() {\r\n        return this._skeleton;\r\n    }\r\n\r\n    /**\r\n     * 替换插槽皮肤\r\n     * @param slotName \r\n     * @param attachmentName \r\n     */\r\n    setSlotAttachment(slotName: string, attachmentName: string) {\r\n        this._skeleton.setAttachment(slotName, attachmentName);\r\n    }\r\n}","import { FilterMode } from \"../RenderEngine/RenderEnum/FilterMode\";\r\nimport { WrapMode } from \"../RenderEngine/RenderEnum/WrapMode\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { Texture2D } from \"../resource/Texture2D\";\r\n\r\nexport class SpineTexture {\r\n    realTexture: Texture;\r\n\r\n    constructor(tex: Texture) {\r\n        this.realTexture = tex;\r\n    }\r\n\r\n    getImage(): Object {\r\n        return {\r\n            width: (this.realTexture?.sourceWidth) ?? 16,\r\n            height: (this.realTexture?.sourceHeight) ?? 16,\r\n        };\r\n    }\r\n\r\n    setFilters(minFilter: spine.TextureFilter, magFilter: spine.TextureFilter) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let filterMode: number;\r\n        if (magFilter === spine.TextureFilter.Nearest)\r\n            filterMode = FilterMode.Point;\r\n        else\r\n            filterMode = FilterMode.Bilinear;\r\n        (<Texture2D>this.realTexture.bitmap).filterMode = filterMode;\r\n    }\r\n\r\n    convertWrapMode(mode: spine.TextureWrap) {\r\n        return mode == spine.TextureWrap.ClampToEdge ? WrapMode.Clamp : (mode == spine.TextureWrap.MirroredRepeat ? WrapMode.Mirrored : WrapMode.Repeat);\r\n    }\r\n\r\n    setWraps(uWrap: spine.TextureWrap, vWrap: spine.TextureWrap) {\r\n        if (!this.realTexture)\r\n            return;\r\n\r\n        let tex2D = <Texture2D>this.realTexture.bitmap;\r\n        tex2D.wrapModeU = this.convertWrapMode(uWrap);\r\n        tex2D.wrapModeV = this.convertWrapMode(vWrap);\r\n    }\r\n}","import { ILaya } from \"../../ILaya\";\r\nimport { Resource } from \"../resource/Resource\";\r\nimport { Texture } from \"../resource/Texture\";\r\nimport { URL } from \"../net/URL\";\r\nimport { ILoadURL } from \"../net/Loader\";\r\nimport { SpineTexture } from \"./SpineTexture\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\n\r\n/**\r\n * Spine动画模板基类\r\n */\r\nexport class SpineTemplet extends Resource {\r\n    public static RuntimeVersion: string = \"3.8\";\r\n\r\n    public skeletonData: spine.SkeletonData;\r\n\r\n    private _textures: Record<string, SpineTexture>;\r\n    private _basePath: string;\r\n    private _ns: any;\r\n\r\n    constructor() {\r\n        super();\r\n\r\n        this._textures = {};\r\n    }\r\n\r\n    get ns(): typeof spine {\r\n        return this._ns;\r\n    }\r\n\r\n    get basePath(): string {\r\n        return this._basePath;\r\n    }\r\n\r\n    getTexture(name: string): SpineTexture {\r\n        return this._textures[name];\r\n    }\r\n\r\n    _parse(desc: string | ArrayBuffer, atlasText: string, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        this._basePath = URL.getPath(createURL);\r\n        let version = this.getRuntimeVersion(desc);\r\n        let parseAtlas;\r\n        if (version == \"4.0\")\r\n            parseAtlas = this.parseAtlas4;\r\n        else\r\n            parseAtlas = this.parseAtlas3;\r\n\r\n        return parseAtlas.call(this, atlasText, progress).then((atlas: any) => {\r\n            let atlasLoader = new this._ns.AtlasAttachmentLoader(atlas);\r\n            if (desc instanceof ArrayBuffer) {\r\n                let skeletonBinary = new this._ns.SkeletonBinary(atlasLoader);\r\n                this.skeletonData = skeletonBinary.readSkeletonData(new Uint8Array(desc));\r\n            } else {\r\n                let skeletonJson = new this._ns.SkeletonJson(atlasLoader);\r\n                this.skeletonData = skeletonJson.readSkeletonData(desc);\r\n            }\r\n        });\r\n    }\r\n\r\n    private getRuntimeVersion(desc: string | ArrayBuffer): string {\r\n        this._ns = spine;\r\n        return SpineTemplet.RuntimeVersion;\r\n    }\r\n\r\n    private parseAtlas3(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlasPages: Array<ILoadURL> = [];\r\n        new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n            atlasPages.push({ url: this._basePath + path });\r\n            return new SpineTexture(null);\r\n        });\r\n        return ILaya.loader.load(atlasPages, null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n            let i = 0;\r\n            let atlas = new this._ns.TextureAtlas(atlasText, (path: string) => {\r\n                let tex = res[i++];\r\n                if (tex)\r\n                    tex._addReference();\r\n                let spineTex = new SpineTexture(tex);\r\n                this._textures[path] = spineTex;\r\n                return spineTex;\r\n            });\r\n            return atlas;\r\n        });\r\n    }\r\n\r\n    private parseAtlas4(atlasText: string, progress?: IBatchProgress): Promise<spine.TextureAtlas> {\r\n        let atlas = new this._ns.TextureAtlas(atlasText);\r\n        return ILaya.loader.load(atlas.pages.map((page: spine.TextureAtlasPage) => this._basePath + page.name),\r\n            null, progress?.createCallback()).then((res: Array<Texture>) => {\r\n                let i = 0;\r\n                for (let page of atlas.pages) {\r\n                    let tex = res[i++];\r\n                    if (tex)\r\n                        tex._addReference();\r\n                    let spineTex = new SpineTexture(tex);\r\n                    this._textures[page.name] = spineTex;\r\n                    page.setTexture(spineTex);\r\n                }\r\n\r\n                return atlas;\r\n            });\r\n    }\r\n\r\n    /**\r\n     * 通过索引得动画名称\r\n     * @param\tindex\r\n     * @return\r\n     */\r\n    getAniNameByIndex(index: number): string {\r\n        let tAni: any = this.skeletonData.animations[index];\r\n        if (tAni) return tAni.name;\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * 通过皮肤名字得到皮肤索引\r\n     * @param\tskinName 皮肤名称\r\n     * @return\r\n     */\r\n    getSkinIndexByName(skinName: string): number {\r\n        let skins = this.skeletonData.skins;\r\n        let tSkinData: spine.Skin;\r\n        for (let i: number = 0, n: number = skins.length; i < n; i++) {\r\n            tSkinData = skins[i];\r\n            if (tSkinData.name == skinName) {\r\n                return i;\r\n            }\r\n        }\r\n        return -1;\r\n    }\r\n\r\n    /**\r\n     * 释放纹理\r\n     * @override\r\n     */\r\n    protected _disposeResource(): void {\r\n        for (let k in this._textures) {\r\n            this._textures[k].realTexture?._removeReference();\r\n        }\r\n    }\r\n}\r\n","import { IResourceLoader, ILoadTask, Loader } from \"../net/Loader\";\r\nimport { Utils } from \"../utils/Utils\";\r\nimport { SpineTemplet } from \"./SpineTemplet\";\r\n\r\nclass SpineTempletLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        let atlasUrl = Utils.replaceFileExtension(task.url, \"atlas\");\r\n\r\n        return Promise.all([\r\n            task.loader.fetch(task.url, task.ext == \"skel\" ? \"arraybuffer\" : \"json\", task.progress.createCallback()),\r\n            task.loader.fetch(atlasUrl, \"text\", task.progress.createCallback())\r\n        ]).then(res => {\r\n            if (!res[0] || !res[1])\r\n                return null;\r\n\r\n            let templet = new SpineTemplet();\r\n            return templet._parse(res[0], res[1], task.url, task.progress).then(() => templet);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"skel\"], SpineTempletLoader, Loader.SPINE);","import { ClassUtils } from \"../utils/ClassUtils\";\r\nimport { ExternalSkin } from \"./ExternalSkin\";\r\nimport { ExternalSkinItem } from \"./ExternalSkinItem\";\r\nimport { SpineSkeleton } from \"./SpineSkeleton\";\r\nimport \"./SpineTempletLoader\";\r\n\r\nlet c = ClassUtils.regClass;\r\n\r\nc(\"SpineSkeleton\", SpineSkeleton);\r\nc(\"ExternalSkin\", ExternalSkin);\r\nc(\"ExternalSkinItem\", ExternalSkinItem);"],"mappings":"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"}