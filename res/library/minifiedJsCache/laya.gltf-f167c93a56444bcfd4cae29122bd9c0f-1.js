!function(e,t){"use strict";class glTFShader{static init(){if(this.Define_BaseMap=t.Shader3D.getDefineByName("BASECOLORMAP"),this.Define_MetallicRoughnessMap=t.Shader3D.getDefineByName("METALLICROUGHNESSMAP"),this.Define_NormalMap=t.Shader3D.getDefineByName("NORMALMAP"),this.Define_OcclusionMap=t.Shader3D.getDefineByName("OCCLUSIONMAP"),this.Define_EmissionMap=t.Shader3D.getDefineByName("EMISSIONMAP"),this.Define_ClearCoatMap=t.Shader3D.getDefineByName("CLEARCOATMAP"),this.Define_ClearCoatRoughnessMap=t.Shader3D.getDefineByName("CLEARCOAT_ROUGHNESSMAP"),this.Define_ClearCoatNormalMap=t.Shader3D.getDefineByName("CLEARCOAT_NORMAL"),this.Define_AnisotropyMap=t.Shader3D.getDefineByName("ANISOTROPYMAP"),t.Shader3D.find(glTFShader.name))return;let e={u_AlphaTestValue:t.ShaderDataType.Float,u_BaseColorFactor:t.ShaderDataType.Vector4,u_BaseColorTexture:t.ShaderDataType.Texture2D,u_MetallicFactor:t.ShaderDataType.Float,u_RoughnessFactor:t.ShaderDataType.Float,u_MetallicRoughnessTexture:t.ShaderDataType.Texture2D,u_NormalTexture:t.ShaderDataType.Texture2D,u_NormalScale:t.ShaderDataType.Float,u_OcclusionTexture:t.ShaderDataType.Texture2D,u_OcclusionStrength:t.ShaderDataType.Float,u_EmissionFactor:t.ShaderDataType.Vector3,u_EmissionTexture:t.ShaderDataType.Texture2D,u_EmissionStrength:t.ShaderDataType.Float,u_ClearCoatFactor:t.ShaderDataType.Float,u_ClearCoatTexture:t.ShaderDataType.Texture2D,u_ClearCoatRoughness:t.ShaderDataType.Float,u_ClearCoatRoughnessTexture:t.ShaderDataType.Texture2D,u_ClearCoatNormalTexture:t.ShaderDataType.Texture2D,u_ClearCoatNormalScale:t.ShaderDataType.Float,u_AnisotropyStrength:t.ShaderDataType.Float,u_AnisotropyRotation:t.ShaderDataType.Float,u_AnisotropyTexture:t.ShaderDataType.Texture2D},r={u_AlphaTestValue:.5,u_BaseColorFactor:t.Vector4.ONE,u_MetallicFactor:1,u_RoughnessFactor:1,u_NormalScale:1,u_OcclusionStrength:1,u_EmissionFactor:t.Vector3.ZERO,u_EmissionStrength:1,u_ClearCoatFactor:0,u_ClearCoatRoughness:0,u_ClearCoatNormalScale:1,u_AnisotropyStrength:0,u_AnisotropyRotation:0},a=t.Shader3D.add("glTFPBR",!0,!0),n=new t.SubShader(t.SubShader.DefaultAttributeMap,e,r);a.addSubShader(n),n.addShaderPass('#define SHADER_NAME glTFPBRVS\r\n\r\n#include "Math.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFogInput.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DVertex.glsl";\r\n\r\n#include "VertexCommon.glsl";\r\n\r\n#include "PBRVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\r\n#ifdef FOG\r\n    FogHandle(gl_Position.z);\r\n#endif\r\n}','#define SHADER_NAME glTFPBRFS\r\n\r\n#include "Color.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFog.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DFrag.glsl";\r\n\r\n#include "PBRMetallicFrag.glsl";\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    vec2 uv = vec2(0.0);\r\n#ifdef UV\r\n    uv = pixel.uv0;\r\n#endif //\r\n\r\n    // render state\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n    // surface\r\n    inputs.diffuseColor = u_BaseColorFactor.xyz;\r\n    inputs.alpha = u_BaseColorFactor.w;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n#ifdef BASECOLORMAP\r\n    vec4 baseColorSampler = texture2D(u_BaseColorTexture, uv);\r\n#ifdef Gamma_u_BaseColorTexture\r\n    baseColorSampler = gammaToLinear(baseColorSampler);\r\n#endif // u_BaseColorTexture_Gamma\r\n    inputs.diffuseColor *= baseColorSampler.rgb;\r\n    inputs.alpha *= baseColorSampler.a;\r\n#endif // BASECOLORMAP\r\n\r\n    inputs.metallic = u_MetallicFactor;\r\n    float roughness = u_RoughnessFactor;\r\n#ifdef METALLICROUGHNESSMAP\r\n    vec4 metallicRoughnessSampler = texture2D(u_MetallicRoughnessTexture, uv);\r\n    inputs.metallic *= metallicRoughnessSampler.b;\r\n    roughness *= metallicRoughnessSampler.g;\r\n#endif // METALLICROUGHNESSMAP\r\n    inputs.smoothness = 1.0 - roughness;\r\n\r\n    float occlusion = 1.0;\r\n#ifdef OCCLUSIONMAP\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, uv);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n    occlusion = occlusionSampler.r;\r\n#endif // OCCLUSIONMAP\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n\r\n    inputs.emissionColor = u_EmissionFactor * u_EmissionStrength;\r\n#ifdef EMISSIONMAP\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, uv);\r\n    #ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n    #endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n#endif // EMISSIONMAP\r\n\r\n    inputs.normalTS = vec3(0.0, 0.0, 1.0);\r\n#ifdef NORMALMAP\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    inputs.normalTS = normalScale(normalSampler, u_NormalScale);\r\n#endif // NORMALMAP\r\n\r\n#ifdef CLEARCOAT\r\n    inputs.clearCoat = u_ClearCoatFactor;\r\n    inputs.clearCoatRoughness = u_ClearCoatRoughness;\r\n\r\n    #ifdef CLEARCOATMAP\r\n    vec4 clearCoatSampler = texture2D(u_ClearCoatTexture, uv);\r\n    inputs.clearCoat *= clearCoatSampler.r;\r\n    #endif // CLEARCOATMAP\r\n\r\n    #ifdef CLEARCOAT_ROUGHNESSMAP\r\n    vec4 clearcoatSampleRoughness = texture2D(u_ClearCoatRoughnessTexture, uv);\r\n    inputs.clearCoatRoughness *= clearcoatSampleRoughness.g;\r\n    #endif // CLEARCOAT_ROUGHNESSMAP\r\n\r\n    #ifdef CLEARCOAT_NORMAL\r\n    vec3 clearCoatNormalSampler = texture2D(u_ClearCoatNormalTexture, uv).rgb;\r\n    clearCoatNormalSampler = normalize(clearCoatNormalSampler * 2.0 - 1.0);\r\n    clearCoatNormalSampler.y *= -1.0;\r\n    // todo scale\r\n    inputs.clearCoatNormalTS = normalScale(clearCoatNormalSampler, u_ClearCoatNormalScale);\r\n    #endif // CLEARCOAT_NORMAL\r\n#endif // CLEARCOAT\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_AnisotropyStrength;\r\n    vec2 direction = vec2(1.0, 0.0);\r\n\r\n    #ifdef ANISOTROPYMAP\r\n    vec3 anisotropySampler = texture2D(u_AnisotropyTexture, uv).rgb;\r\n\r\n    inputs.anisotropy *= anisotropySampler.b;\r\n    direction = anisotropySampler.xy * 2.0 - 1.0;\r\n    #endif // ANISOTROPYMAP\r\n\r\n    vec2 anisotropyRotation = vec2(cos(u_AnisotropyRotation), sin(u_AnisotropyRotation));\r\n    mat2 rotationMatrix = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x);\r\n    inputs.anisotropyDirection = rotationMatrix * direction;\r\n\r\n#endif // ANISOTROPIC\r\n}\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = PBR_Metallic_Flow(inputs, pixel);\r\n\r\n#ifdef FOG\r\n    surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n#endif // FOG\r\n\r\n    gl_FragColor = surfaceColor;\r\n\r\n    gl_FragColor = outputTransform(gl_FragColor);\r\n\r\n    // // debug\r\n    // Surface surface;\r\n    // initSurface(surface, inputs, pixel);\r\n\r\n    // // PixelInfo info;\r\n    // // getPixelInfo(info, pixel, surface);\r\n\r\n    // vec3 debug = vec3(0.0);\r\n\r\n    // debug = vec3(1.0 - inputs.smoothness);\r\n\r\n    // debug = gammaToLinear(debug);\r\n    // gl_FragColor = vec4(debug, 1.0);\r\n}'),n.addShaderPass('#define SHADER_NAME glTFDepthVS\r\n\r\n#include "DepthVertex.glsl";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0));\r\n    vec3 positionWS = pos.xyz / pos.w;\r\n\r\n    mat4 normalMat = transpose(inverse(worldMat));\r\n    vec3 normalWS = normalize((normalMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}','#define SHADER_NAME glTFDepthFS\r\n\r\n#include "DepthFrag.glsl";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}',"ShadowCaster"),n.addShaderPass('#define SHADER_NAME glTFPBRDepthNormalVS\r\n\r\n#include "Math.glsl";\r\n\r\n#include "Camera.glsl";\r\n\r\n#include "Sprite3DVertex.glsl";\r\n\r\n#include "VertexCommon.glsl";\r\n\r\n#include "PBRVertex.glsl";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    sharePixelParams(pixel);\r\n\r\n    vec4 positionCS = getPositionCS(pixel.positionWS);\r\n    v_PositionCS = positionCS;\r\n    gl_Position = positionCS;\r\n    gl_Position = remapPositionZ(gl_Position);\r\n}','#define SHADER_NAME glTFPBRDepthNormalFS\r\n\r\n#include "Color.glsl";\r\n\r\n#include "Scene.glsl";\r\n#include "SceneFog.glsl";\r\n\r\n#include "Camera.glsl";\r\n#include "Sprite3DFrag.glsl";\r\n\r\n#include "ShadingFrag.glsl";\r\n\r\n#include "DepthNormalFrag.glsl";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n#ifdef NORMALMAP\r\n    #ifdef UV\r\n\r\n    vec2 uv = pixel.uv0;\r\n\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    vec3 normalTS = normalScale(normalSampler, u_NormalScale);\r\n    normalWS = normalize(pixel.TBN * normalTS);\r\n\r\n    #endif UV\r\n#endif // NORMALMAP\r\n\r\n    vec4 positionCS = v_PositionCS;\r\n\r\n    vec4 dephtNormal = encodeDepthNormal(positionCS, normalWS);\r\n\r\n    gl_FragColor = dephtNormal;\r\n}',"DepthNormal")}}glTFShader.ShaderName="glTFPBR";class glTFResource extends t.Prefab{constructor(){super(3),this._buffers={},this._textures=[],this._materials=[],this._meshes={},this._extensions=[],this._pendingOps=[],this._scenes=[],this._nodes=[]}static registerExtension(e,t){this._Extensions[e]=t}get data(){return this._data}loadBinary(e,r){let a=this._data;if(a.buffers){let n=[];return a.buffers.forEach(((a,s)=>{if(t.Base64Tool.isBase64String(a.uri)){let e=t.Base64Tool.decode(a.uri.replace(t.Base64Tool.reghead,""));this._buffers[s]=e}else{let l=s;n.push(t.ILaya.loader.fetch(t.URL.join(e,a.uri),"arraybuffer",null==r?void 0:r.createCallback(.2)).then((e=>{this._buffers[l]=e})))}})),Promise.all(n)}return Promise.resolve()}loadTextureFromglTF(e,r,a,n){let s=this._data,l=s.textures[e],o=l.source,i=s.images[o],u=l.sampler,h=s.samplers?s.samplers[u]:void 0,c=this.getTextureConstructParams(i,h,r),d=this.getTexturePropertyParams(h);if(null!=i.bufferView){let t=s.bufferViews[i.bufferView],r=this._buffers[t.buffer],a=t.byteOffset||0,l=t.byteLength,o=r.slice(a,a+l);return this.loadTextureFromBuffer(o,i.mimeType,c,d,n).then((t=>(this._textures[e]=t,this.addDep(t),t)))}return this.loadTexture(t.URL.join(a,i.uri),c,d,n).then((t=>(this._textures[e]=t,this.addDep(t),t)))}loadTextures(e,t){let r=this._data,a=r.materials,n=r.textures,s=[];if(a&&n)for(let a of r.materials){let r=a.pbrMetallicRoughness;if(r){if(r.baseColorTexture){let a=r.baseColorTexture.index,n=!0,l=this.loadTextureFromglTF(a,n,e,t);s.push(l)}if(r.metallicRoughnessTexture){let a=r.metallicRoughnessTexture.index,n=!1,l=this.loadTextureFromglTF(a,n,e,t);s.push(l)}}if(a.normalTexture){let r=a.normalTexture.index,n=!1,l=this.loadTextureFromglTF(r,n,e,t);s.push(l)}if(a.occlusionTexture){let r=a.occlusionTexture.index,n=!1,l=this.loadTextureFromglTF(r,n,e,t);s.push(l)}if(a.emissiveTexture){let r=a.emissiveTexture.index,n=!0,l=this.loadTextureFromglTF(r,n,e,t);s.push(l)}}return this._extensions.forEach((r=>{if(r.loadTextures){let a=r.loadTextures(e,t);s.push(a)}})),Promise.all(s)}importMaterials(){return Promise.resolve().then((()=>{let e=this._data;e.materials&&e.materials.forEach(((e,t)=>{let r=this.createMaterial(e);this._materials[t++]=r,this.addDep(r)}))}))}importMeshes(){return Promise.resolve().then((()=>{let e=this._data;e.meshes&&e.nodes&&e.nodes.forEach((e=>{var t;if(null!=e.mesh){let r=this._data.meshes[e.mesh],a=null===(t=this._data.skins)||void 0===t?void 0:t[e.skin],n=e.mesh+(null!=e.skin?"_"+e.skin:""),s=this._meshes[n];s||(s=this.createMesh(r,a),this._meshes[n]=s,this.addDep(s))}}))}))}_parse(e,r,a){var n;if(!e.asset||"2.0"!==e.asset.version)throw new Error("glTF version wrong!");this._data=e;let s=t.URL.getPath(r);this._idCounter={},null===(n=e.extensionsUsed)||void 0===n||n.forEach((e=>{let t=glTFResource._Extensions[e];t?this._extensions.push(t(this)):console.warn(`glTF: unsupported extension: ${e}`)}));let l=this.loadBinary(s,a);return l=l.then((()=>this.loadTextures(s,a))),l=l.then((()=>this.importMeshes())),l=l.then((()=>this.importMaterials())),l.then((()=>this._pendingOps.length>0?Promise.all(this._pendingOps).then((()=>{this._idCounter=null})):(this._idCounter=null,Promise.resolve())))}_parseglb(e,r,a){var n,s;let l=t.URL.getPath(r);this._idCounter={};let o=new t.Byte(e);if(1179937895!=o.readUint32())throw new Error("glb fromat wrong!");if(2!=o.readUint32())throw new Error("glb version wrong!");o.readUint32();let i=o.readUint32();if(1313821514!=o.readUint32())throw new Error("glb json chunk data wrong!");let u=o.readArrayBuffer(i),h=(new TextDecoder).decode(u),c=JSON.parse(h);this._data=c;let d=o.readUint32();if(5130562!=o.readUint32())throw new Error("glb bin chunk data wrong!");let m=null===(n=c.buffers)||void 0===n?void 0:n[0];m.byteLength=m.byteLength?Math.min(m.byteLength,d):d,this._buffers[0]=o.readArrayBuffer(m.byteLength),null===(s=c.extensionsUsed)||void 0===s||s.forEach((e=>{let t=glTFResource._Extensions[e];t?this._extensions.push(t(this)):console.warn(`glTF: unsupported extension: ${e}`)}));let f=this.loadTextures(l,a);return f=f.then((()=>this.importMeshes())),f=f.then((()=>this.importMaterials())),f.then((()=>this._pendingOps.length>0?Promise.all(this._pendingOps).then((()=>{this._idCounter=null})):(this._idCounter=null,Promise.resolve())))}create(){let e=this._data;this._scenes.length=0,this._nodes.length=0,this._idCounter={},this.loadNodes(e.nodes),this.buildHierarchy(e.nodes),this.loadScenes(e.scenes),this.loadAnimations(e.animations);let t=null!=e.scene?e.scene:0,r=this._scenes[t];return this._scenes.length=0,this._nodes.length=0,this._idCounter=null,r}loadTextureFromBuffer(e,r,a,n,s){let l=`data:${r};base64,${t.Base64Tool.encode(e)}`;return t.ILaya.loader.load({url:l,constructParams:a,propertyParams:n},t.Loader.TEXTURE2D,null==s?void 0:s.createCallback())}loadTexture(e,r,a,n){return t.ILaya.loader.load({url:e,constructParams:r,propertyParams:a},t.Loader.TEXTURE2D,null==n?void 0:n.createCallback())}generateId(e){let t=this._idCounter[e];return null==t?t=0:t++,this._idCounter[e]=t,t.toString()}getAccessorComponentsNum(e){switch(e){case"SCALAR":return 1;case"VEC2":return 2;case"VEC3":return 3;case"VEC4":case"MAT2":return 4;case"MAT3":return 9;case"MAT4":return 16;default:return 0}}getAttributeNum(e){switch(e){case"POSITION":case"NORMAL":return 3;case"COLOR":case"BLENDWEIGHT":case"BLENDINDICES":case"TANGENT":return 4;case"UV":case"UV1":return 2;default:return 0}}_getTypedArrayConstructor(e){switch(e){case 5120:return Int8Array;case 5121:return Uint8Array;case 5122:return Int16Array;case 5123:return Uint16Array;case 5125:return Uint32Array;case 5126:return Float32Array}}_getAccessorDateByteStride(e){switch(e){case 5120:case 5121:return 1;case 5122:case 5123:return 2;case 5125:case 5126:return 4}}getBufferFormBufferView(e,t,r,a,n){let s=this._buffers[e.buffer];const l=this._getTypedArrayConstructor(a);let o,i=this.getAccessorComponentsNum(r);if(e.byteStride){let r=e.byteStride,u=this._getAccessorDateByteStride(a),h=r/u,c=(t||0)/u,d=new l(s,e.byteOffset||0,e.byteLength/u);o=new l(n);let m=0;for(let e=0;e<n;e++){let t=e*h;for(let e=0;e<i;e++)o[m++]=d[t+c+e]}}else{o=new l(s,(e.byteOffset||0)+(t||0),n)}return o}getBufferwithAccessorIndex(e){let t=this._data.accessors[e];if(!t)return null;let r,a=t.count,n=this.getAccessorComponentsNum(t.type),s=a*n,l=this._data.bufferViews[t.bufferView];if(l)r=this.getBufferFormBufferView(l,t.byteOffset,t.type,t.componentType,s);else{r=new(this._getTypedArrayConstructor(t.componentType))(s).fill(0)}if(t.sparse){let e=t.sparse.count,a=t.sparse.indices,s=this._data.bufferViews[a.bufferView],l=this.getBufferFormBufferView(s,a.byteOffset,t.type,a.componentType,e),o=t.sparse.values,i=this._data.bufferViews[o.bufferView],u=this.getBufferFormBufferView(i,o.byteOffset,t.type,t.componentType,e*n);for(let t=0;t<e;t++){let e=l[t];for(let a=0;a<n;a++)r[e*n+a]=u[t*n+a]}}return r}getTextureMipmap(e){return!e||9729!=e.minFilter&&9728!=e.minFilter}getTextureFormat(e){return"image/jpeg"===e.mimeType?0:1}getTextureFilterMode(e){return e?9728===e.magFilter?0:this.getTextureMipmap(e)&&9987===e.minFilter?2:1:1}getTextureWrapMode(e){return 33071===e?1:0}getTextureConstructParams(e,t,r){return[0,0,this.getTextureFormat(e),this.getTextureMipmap(t),!1,r]}getTexturePropertyParams(e){if(!e)return null;return{filterMode:this.getTextureFilterMode(e),wrapModeU:this.getTextureWrapMode(e.wrapS),wrapModeV:this.getTextureWrapMode(e.wrapT),anisoLevel:1,hdrEncodeFormat:t.HDREncodeFormat.NONE}}getTextureWithInfo(e){return e.texCoord&&console.warn("glTF Loader: non 0 uv channel unsupported."),this._textures[e.index]}applyMaterialRenderState(e,r){var a;switch(e.alphaMode||"OPAQUE"){case"OPAQUE":r.materialRenderMode=t.MaterialRenderMode.RENDERMODE_OPAQUE;break;case"BLEND":r.materialRenderMode=t.MaterialRenderMode.RENDERMODE_TRANSPARENT;break;case"MASK":r.materialRenderMode=t.MaterialRenderMode.RENDERMODE_CUTOUT}r.alphaTestValue=null!==(a=e.alphaCutoff)&&void 0!==a?a:.5,e.doubleSided&&(r.cull=t.RenderState.CULL_NONE)}applyDefaultMaterialProperties(e,r){var a,n,s,l;{let o=e.pbrMetallicRoughness;if(o){if(o.baseColorFactor){let e=r.getVector4("u_BaseColorFactor");e.fromArray(o.baseColorFactor),r.setVector4("u_BaseColorFactor",e)}if(o.baseColorTexture){let e=this.getTextureWithInfo(o.baseColorTexture);r.setTexture("u_BaseColorTexture",e),r.setDefine(glTFShader.Define_BaseMap,!0)}let e=null!==(a=o.metallicFactor)&&void 0!==a?a:1;r.setFloat("u_MetallicFactor",e);let t=null!==(n=o.roughnessFactor)&&void 0!==n?n:1;if(r.setFloat("u_RoughnessFactor",t),o.metallicRoughnessTexture){let e=this.getTextureWithInfo(o.metallicRoughnessTexture);r.setTexture("u_MetallicRoughnessTexture",e),r.setDefine(glTFShader.Define_MetallicRoughnessMap,!0)}}if(e.normalTexture){let t=this.getTextureWithInfo(e.normalTexture);r.setTexture("u_NormalTexture",t),r.setDefine(glTFShader.Define_NormalMap,!0);let a=null!==(s=e.normalTexture.scale)&&void 0!==s?s:1;r.setFloat("u_NormalScale",a)}if(e.occlusionTexture){let t=this.getTextureWithInfo(e.occlusionTexture);r.setTexture("u_OcclusionTexture",t),r.setDefine(glTFShader.Define_OcclusionMap,!0);let a=null!==(l=e.occlusionTexture.strength)&&void 0!==l?l:1;r.setFloat("u_OcclusionStrength",a)}if(e.emissiveFactor){let a=r.getVector3("u_EmissionFactor");a.fromArray(e.emissiveFactor),r.setVector3("u_EmissionFactor",a),r.setDefine(t.PBRShaderLib.DEFINE_EMISSION,!0)}if(e.emissiveTexture){let a=this.getTextureWithInfo(e.emissiveTexture);r.setTexture("u_EmissionTexture",a),r.setDefine(t.PBRShaderLib.DEFINE_EMISSION,!0),r.setDefine(glTFShader.Define_EmissionMap,!0)}this.applyMaterialRenderState(e,r)}}createDefaultMaterial(e){let r=new t.Material;return r.setShaderName(glTFShader.ShaderName),r.name=e.name?e.name:"",this.applyDefaultMaterialProperties(e,r),r}createMaterial(e){let t=null,r=[];for(const a in e.extensions){let n=this._extensions.find((e=>e.name==a));n&&(n.createMaterial&&(t=n.createMaterial(e)),n.additionMaterialProperties&&r.push(n))}return t||(t=this.createDefaultMaterial(e)),r.forEach((r=>{r.additionMaterialProperties(e,t)})),t}pickMeshMaterials(e){let r=[];return e.primitives.forEach((e=>{if(null!=e.material){let t=this._materials[e.material];r.push(t)}else{let a=new t.PBRStandardMaterial;r.push(a),this._materials.push(a),e.material=this._materials.indexOf(a)}})),r}loadScenes(e){e&&e.forEach(((e,t)=>{this._scenes[t]=this._loadScene(e)}))}_loadScene(e){return this._createSceneNode(e)}_createSceneNode(e){let r=new t.Sprite3D(e.name||"Scene");return e.nodes.forEach((e=>{let t=this._nodes[e];r.addChild(t)})),r}applyTransform(e,t){if(e.matrix){let r=t.transform.localMatrix;r.elements.set(e.matrix),t.transform.localMatrix=r}else{let r=t.transform.localPosition,a=t.transform.localRotation,n=t.transform.localScale;e.translation&&r.fromArray(e.translation),e.rotation&&a.fromArray(e.rotation),e.scale&&n.fromArray(e.scale),t.transform.localPosition=r,t.transform.localRotation=a,t.transform.localScale=n}}buildHierarchy(e){e.forEach(((e,t)=>{let r=this._nodes[t];e.children&&e.children.forEach((e=>{let t=this._nodes[e];r.addChild(t)}))})),e.forEach(((e,r)=>{let a=this._nodes[r];a instanceof t.SkinnedMeshSprite3D&&this.fixSkinnedSprite(e,a)}))}loadNodes(e){e&&e.forEach(((e,t)=>{this._nodes[t]=this.loadNode(e)}))}loadNode(e){return this.createSprite3D(e)}createSprite3D(e){let r;null!=e.skin?(r=this.createSkinnedMeshSprite3D(e),this.applyTransform(e,r)):null!=e.mesh?(r=this.createMeshSprite3D(e),this.applyTransform(e,r)):(r=new t.Sprite3D(e.name),this.applyTransform(e,r));let a=this.generateId("node");return r.name=e.name||`node_${a}`,r._extra.storeId="#"+a,r}createMeshSprite3D(e){let r=this._data.meshes[e.mesh],a=this._meshes[e.mesh],n=this.pickMeshMaterials(r),s=new t.MeshSprite3D(a,e.name);if(s.meshRenderer.sharedMaterials=n,s.meshRenderer.receiveShadow=!0,s.meshRenderer.castShadow=!0,r.weights){let e=s.meshRenderer;r.weights.forEach(((t,r)=>{let n=a.morphTargetData.getMorphChannelbyIndex(r);e.setMorphChannelWeight(n.name,t)}))}return s}createSkinnedMeshSprite3D(e){let r=this._data.meshes[e.mesh],a=this._meshes[e.mesh+"_"+e.skin],n=this.pickMeshMaterials(r),s=new t.SkinnedMeshSprite3D(a,e.name);if(s.skinnedMeshRenderer.sharedMaterials=n,s.skinnedMeshRenderer.receiveShadow=!0,s.skinnedMeshRenderer.castShadow=!0,r.weights){let e=s.skinnedMeshRenderer;r.weights.forEach(((t,r)=>{let n=a.morphTargetData.getMorphChannelbyIndex(r);e.setMorphChannelWeight(n.name,t)}))}return s}getArrributeBuffer(e,t,r,a){let n=this.getBufferwithAccessorIndex(e);if(!n)return null;a.push(t);let s=n;return r.set(t,s),s}getIndexBuffer(e,t){let r=this.getBufferwithAccessorIndex(e);if(r)return new Uint32Array(r).reverse();{let e=new Uint32Array(t);for(let r=0;r<t;r++)e[r]=t-1-r;return e}}calculateFlatNormal(e,t){let r=new Float32Array(e.length);for(let a=0;a<t.length;a+=3){let n=t[a],s=t[a+1],l=t[a+2],o=e[3*n],i=e[3*n+1],u=e[3*n+2],h=e[3*s]-o,c=e[3*s+1]-i,d=e[3*s+2]-u,m=e[3*l]-o,f=e[3*l+1]-i,p=e[3*l+2]-u,g=c*p-d*f,x=d*m-h*p,_=h*f-c*m,T=-1/Math.sqrt(g*g+x*x+_*_),A=g*T,y=x*T,S=_*T;r[3*n]=A,r[3*s]=A,r[3*l]=A,r[3*n+1]=y,r[3*s+1]=y,r[3*l+1]=y,r[3*n+2]=S,r[3*s+2]=S,r[3*l+2]=S}return r}parseMeshwithSubMeshData(e,r){let a,n=0,s=0;e.forEach((e=>{n+=e.vertexCount,s+=e.indices.length,a=a||e.vertexDecler}));let l,o=t.VertexMesh.getVertexDeclaration(a,!1),i=o.vertexStride/4,u=new Float32Array(i*n),h=t.IndexFormat.UInt32;n<65536?(l=new Uint16Array(s),h=t.IndexFormat.UInt16):l=new Uint32Array(s),this.fillMeshBuffers(e,u,l,i),this.generateMesh(u,l,o,h,e,r)}fillMeshBuffers(e,t,r,a){let n=0,s=0,l=0;e.forEach((e=>{let o=n,i=e.vertexCount,u=e.indices;for(let e=0;e<u.length;e++)r[o+e]=u[e]+s;n+=u.length,s+=i;const fillAttributeBuffer=(e,r,n=0)=>{let s=l+r;for(let r=0;r<i;r++)for(let l=0;l<n;l++)t[s+r*a+l]=e[r*n+l]};let h=0,c=e.attributeMap,d=c.get("POSITION");d&&(fillAttributeBuffer(d,h,3),h+=3);let m=c.get("NORMAL");m&&(fillAttributeBuffer(m,h,3),h+=3);let f=c.get("COLOR");f&&(fillAttributeBuffer(f,h,4),h+=4);let p=c.get("UV");p&&(fillAttributeBuffer(p,h,2),h+=2);let g=c.get("UV1");g&&(fillAttributeBuffer(g,h,2),h+=2);let x=c.get("BLENDWEIGHT");x&&(fillAttributeBuffer(x,h,4),h+=4);let _=c.get("BLENDINDICES");if(_){let e=new Uint8Array(_);fillAttributeBuffer(new Float32Array(e.buffer),h,1),h+=1}let T=c.get("TANGENT");T&&(fillAttributeBuffer(T,h,4),h+=4),l+=i*a}))}splitSubMeshByBonesCount(e,t,r,a,n,s){let l=0,o=new Set,i=e.get("BLENDINDICES"),u=i.length/4,h=new Float32Array(i.length),c=new Array(u).fill(!1);for(let e=0,t=r.length;e<t;e+=3){let u=new Set;for(let t=e;t<e+3;t++){let e=4*r[t];for(let t=0;t<4;t++)u.add(i[e+t])}let h=new Set([...o,...u]);if(h.size>24){let t=e-l;n.push(l),s.push(t);let r=Array.from(o);a.push(new Uint16Array(r)),l=e,o=new Set(u)}else o=h;if(e==t-3){let t=e-l+3;n.push(l),s.push(t),l=e;let r=Array.from(o);a.push(new Uint16Array(r))}}let d=a.length,m=new Map;e.forEach(((e,t)=>{let r=new Array;m.set(t,r)}));let f={};for(const e in t.targets){let r=f[e]=new Map;t.targets[e].forEach(((e,t)=>{r.set(t,new Array)}))}let p=u-1;for(let l=0;l<d;l++){let o=n[l],d=s[l],g=a[l],x=new Array(u).fill(!1),_=new Map;for(let a=0;a<d;a++){let n=r[a+o],s=4*n;for(let e=s;e<s+4;e++){let t=i[e],r=g.indexOf(t);r=-1==r?0:r,c[n]&&!x[n]?m.get("BLENDINDICES").push(r):c[n]&&x[n]||(h[e]=r)}if(c[n]||x[n])if(!c[n]&&x[n])r[a+o]=_.get(n);else if(c[n]&&!x[n]){x[n]=!0,p++,_.set(n,p),r[a+o]=p,m.forEach(((t,r)=>{let a=this.getAttributeNum(r),s=e.get(r);if("BLENDINDICES"!==r)for(let e=0;e<a;e++)t.push(s[e+n*a])}));for(const e in f){let r=f[e],a=t.targets[e];r.forEach(((e,t)=>{let r=this.getAttributeNum(t),s=a.get(t);for(let t=0;t<r;t++)e.push(s[t+n*r])}))}}else c[n]&&x[n]&&(r[a+o]=_.get(n));else x[n]=!0,_.set(n,n)}x.forEach(((e,t)=>{c[t]=e||c[t]}))}m.forEach(((t,r)=>{let a=e.get(r);"BLENDINDICES"==r&&(a=h);let n=a.length+t.length,s=new Float32Array(n);s.set(a,0),s.set(t,a.length),e.set(r,s)}));for(const e in f){let r=f[e],a=t.targets[e];r.forEach(((e,t)=>{let r=a.get(t),n=e.length+r.length,s=new Float32Array(n);s.set(r,0),s.set(e,r.length),a.set(t,s)}))}i=null}generateMesh(e,r,a,n,s,l){let o=t.LayaGL.renderOBJCreate.createVertexBuffer3D(e.byteLength,t.BufferUsage.Static,!0);o.vertexDeclaration=a,o.setData(e.buffer);let i=t.LayaGL.renderOBJCreate.createIndexBuffer3D(n,r.length,t.BufferUsage.Static,!0);i.setData(r),l._indexFormat=n,l._indexBuffer=i,l._vertexBuffer=o,l._setBuffer(o,i),l._vertexCount=o._byteLength/a.vertexStride;let u=!1,h=new t.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),c=new t.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE),d=0,m=s.length,f=new Array(m);for(let e=0;e<m;e++){let r=s[e],a=new t.SubMesh(l);f[e]=a,a._vertexBuffer=o,a._indexBuffer=i;let m=d;d+=r.indices.length;let p=r.indices.length;a._setIndexRange(m,p,n),a._boneIndicesList=r.boneIndicesList,a._subIndexBufferStart=r.subIndexStartArray,a._subIndexBufferCount=r.subIndexCountArray;for(let e=0;e<a._subIndexBufferStart.length;e++)a._subIndexBufferStart[e]+=m;r.boundMax&&r.boundMin?(h.x=Math.min(r.boundMin[0],h.x),h.y=Math.min(r.boundMin[1],h.y),h.z=Math.min(r.boundMin[2],h.z),c.x=Math.max(r.boundMax[0],c.x),c.y=Math.max(r.boundMax[1],c.y),c.z=Math.max(r.boundMax[2],c.z)):u=!0}l._setSubMeshes(f),u?l.calculateBounds():(l.bounds.setMin(h),l.bounds.setMax(c));let p=o._byteLength+i._byteLength;l._setCPUMemory(p),l._setGPUMemory(p)}applyglTFSkinData(e,r,a){if(!a)return;let n=a.joints,s=new Float32Array(this.getBufferwithAccessorIndex(a.inverseBindMatrices)),l=n.length,o=e._boneNames=[];n.forEach((e=>{let t=this._data.nodes[e];o.push(t.name)})),e._inverseBindPoses=[],e._inverseBindPosesBuffer=s.buffer;for(let r=0;r<l;r++){let a=16*r,n=s.slice(a,a+16);e._inverseBindPoses[r]=new t.Matrix4x4(n[0],n[1],n[2],n[3],n[4],n[5],n[6],n[7],n[8],n[9],n[10],n[11],n[12],n[13],n[14],n[15],n)}let i=r.length,u=e._skinnedMatrixCaches;u.length=e._inverseBindPoses.length;for(let r=0;r<i;r++){let a=e.getSubMesh(r),n=a._subIndexBufferStart.length;for(let e=0;e<n;e++){let n=a._boneIndicesList[e];for(let a=0;a<n.length;a++){let s=n[a];u[s]||(u[s]=new t.skinnedMatrixCache(r,e,a))}}}for(let e=0;e<u.length;e++)u[e]||(u[e]=new t.skinnedMatrixCache(0,0,0))}applyMorphTarget(e,r){let a=!1,n=!1,s=!1;if(r.forEach((e=>{a=e.morphtargets.position||a,n=e.morphtargets.normal||n,s=e.morphtargets.tangent||s})),!(a||s||s))return;let l=e.vertexCount,o=new t.MorphTargetData;o.vertexCount=l;let i=[];a&&i.push("POSITION"),n&&i.push("NORMAL"),s&&i.push("TANGENT");let u=t.VertexMesh.getVertexDeclaration(i.toLocaleString()),h=u.vertexStride/4;o.vertexDec=u;let c=o.bounds,d=c.getMin(),m=c.getMax();d.set(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),m.set(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);let f=0;for(let e=0;e<r.length;e++){let a=r[e];d.x=Math.min(d.x,a.morphtargets.boundMin[0]),d.y=Math.min(d.y,a.morphtargets.boundMin[1]),d.z=Math.min(d.z,a.morphtargets.boundMin[2]),m.x=Math.max(m.x,a.morphtargets.boundMax[0]),m.y=Math.max(m.y,a.morphtargets.boundMax[1]),m.z=Math.max(m.z,a.morphtargets.boundMax[2]);let n=a.morphtargets.targets;for(const e in n){let r=o.getMorphChannel(e);if(!r){r=new t.MorphTargetChannel,r.name=e;let a=new t.MorphTarget;a.name=e,a.data=new Float32Array(l*h).fill(0),r.addTarget(a),o.addMorphChannel(r)}let s=r.getTargetByIndex(0),i=n[e];for(let e=0;e<a.vertexCount;e++){let r=i.get("POSITION");if(r){let a=u.getVertexElementByUsage(t.VertexMesh.MESH_POSITION0).offset/4;s.data[(e+f)*h+a]=r[3*e],s.data[(e+f)*h+a+1]=r[3*e+1],s.data[(e+f)*h+a+2]=r[3*e+2]}let n=i.get("NORMAL");if(n){let r=u.getVertexElementByUsage(t.VertexMesh.MESH_NORMAL0).offset/4;s.data[(e+f)*h+r]=n[3*e],s.data[(e+f)*h+r+1]=n[3*e+1],s.data[(e+f)*h+r+2]=n[3*e+2]}let l=i.get("TANGENT");if(l){let r=u.getVertexElementByUsage(t.VertexMesh.MESH_TANGENT0).offset/4;s.data[(e+f)*h+r]=l[3*e],s.data[(e+f)*h+r+1]=l[3*e+1],s.data[(e+f)*h+r+2]=l[3*e+2],s.data[(e+f)*h+r+3]=a.attributeMap.get("TANGENT")[4*e+3]}}}f+=a.vertexCount}c.setMin(d),c.setMax(m),e.morphTargetData=o,o.initData()}createMesh(e,r){let a=new t.Mesh,n=e.primitives,s=e.weights,l=r?r.joints.length:0,o=[];return n.forEach((t=>{var a;let n=t.mode;null==n&&(n=4),4!=n&&console.warn("glTF Loader: only support gl.TRIANGLES.");let i,u=[],h=new Map,c=t.attributes,d=this.getArrributeBuffer(c.POSITION,"POSITION",h,u),m=d.length/3,f=this.getIndexBuffer(t.indices,m),p=this._data.accessors[c.POSITION],g=this.getArrributeBuffer(c.NORMAL,"NORMAL",h,u);if(g||(g=this.calculateFlatNormal(d,f),u.push("NORMAL"),h.set("NORMAL",g)),this.getArrributeBuffer(c.COLOR_0,"COLOR",h,u),this.getArrributeBuffer(c.TEXCOORD_0,"UV",h,u),this.getArrributeBuffer(c.TEXCOORD_1,"UV1",h,u),this.getArrributeBuffer(c.WEIGHTS_0,"BLENDWEIGHT",h,u),this.getArrributeBuffer(c.JOINTS_0,"BLENDINDICES",h,u),i=this.getArrributeBuffer(c.TANGENT,"TANGENT",h,u),i)for(let e=0;e<i.length;e+=4)i[e+3]*=-1;let x=t.targets,_={weights:s,position:!1,normal:!1,tangent:!1,targets:{},boundMin:[Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE],boundMax:[-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE]};if(x){let t,r=(null===(a=e.extras)||void 0===a?void 0:a.targetNames)||[];t=_.targets,x.forEach(((e,a)=>{let n=r[a]||`target_${a}`,s=new Map;t[n]=s;let l=this.getBufferwithAccessorIndex(e.POSITION),o=this.getBufferwithAccessorIndex(e.NORMAL),i=this.getBufferwithAccessorIndex(e.TANGENT);if(l&&(s.set("POSITION",l),_.position=!0,d)){let e=d.length/3;for(let t=0;t<e;t++){let e=3*t,r=d[e]+l[e],a=d[e+1]+l[e+1],n=d[e+2]+l[e+2];_.boundMin[0]=Math.min(r,_.boundMin[0]),_.boundMin[1]=Math.min(a,_.boundMin[1]),_.boundMin[2]=Math.min(n,_.boundMin[2]),_.boundMax[0]=Math.max(r,_.boundMax[0]),_.boundMax[1]=Math.max(a,_.boundMax[1]),_.boundMax[2]=Math.max(n,_.boundMax[2])}}o&&(s.set("NORMAL",o),_.normal=!0),i&&(s.set("TANGENT",i),_.tangent=!0)}))}let T=new Array,A=[],y=[];if(r)if(l>24)this.splitSubMeshByBonesCount(h,_,f,T,A,y),m=h.get("POSITION").length/3;else{A[0]=0,y[0]=f.length,T[0]=new Uint16Array(l);for(let e=0;e<l;e++)T[0][e]=e}else A[0]=0,y[0]=f.length;let S=u.toString(),M=new PrimitiveSubMesh;o.push(M),M.attributeMap=h,M.boundMax=p.max,M.boundMin=p.min,M.morphtargets=_,M.indices=f,M.vertexCount=m,M.vertexDecler=S,M.boneIndicesList=T,M.subIndexStartArray=A,M.subIndexCountArray=y})),this.parseMeshwithSubMeshData(o,a),this.applyglTFSkinData(a,o,r),this.applyMorphTarget(a,o),a}calSkinnedSpriteLocalBounds(e){let r=e.skinnedMeshRenderer,a=e.meshFilter.sharedMesh,n=r.rootBone.transform.worldMatrix,s=new t.Matrix4x4;n.invert(s);let l=a.getIndices(),o=[],i=[],u=[];a.getPositions(o),a.getBoneIndices(i),a.getBoneWeights(u);let h=[];a._subMeshes.forEach(((e,r)=>{e._boneIndicesList.forEach(((r,a)=>{let n=e._subIndexBufferStart[a],s=e._subIndexBufferCount[a]+n;for(let e=n;e<s;e++){let a=l[e],n=i[a],s=r[n.x],o=r[n.y],u=r[n.z],c=r[n.w];h[a]=new t.Vector4(s,o,u,c)}}))}));let c=a._inverseBindPoses,d=r.bones,m=[],f=new t.Matrix4x4;d.forEach(((e,r)=>{m[r]=new t.Matrix4x4,t.Matrix4x4.multiply(s,e.transform.worldMatrix,f),t.Matrix4x4.multiply(f,c[r],m[r])}));let p=new t.Matrix4x4,g=new t.Vector3,x=new t.Vector3(Number.MAX_VALUE,Number.MAX_VALUE,Number.MAX_VALUE),_=new t.Vector3(-Number.MAX_VALUE,-Number.MAX_VALUE,-Number.MAX_VALUE);for(let e=0;e<o.length;e++){let r=o[e],a=h[e],n=u[e];if(a&&n){for(let e=0;e<16;e++)p.elements[e]=m[a.x].elements[e]*n.x,p.elements[e]+=m[a.y].elements[e]*n.y,p.elements[e]+=m[a.z].elements[e]*n.z,p.elements[e]+=m[a.w].elements[e]*n.w;t.Vector3.transformV3ToV3(r,p,g),t.Vector3.min(x,g,x),t.Vector3.max(_,g,_)}}o=null,i=u=h=null,l=null,m=null,r.localBounds.setMin(x),r.localBounds.setMax(_),r.localBounds=r.localBounds}fixSkinnedSprite(e,t){let r=this._data.skins[e.skin],a=t.skinnedMeshRenderer;r.joints.forEach((e=>{let t=this._nodes[e];a.bones.push(t)})),null==r.skeleton&&(r.skeleton=r.joints[0]),a.rootBone=this._nodes[r.skeleton],this.calSkinnedSpriteLocalBounds(t)}getAnimationRoot(e){const isContainNode=(e,t)=>{if(!e)return!1;if(-1==e.indexOf(t))for(let r=0;r<e.length;r++){let a=this._data.nodes[e[r]];if(isContainNode(a.children,t))return!0}return!0};let t=e[0].target.node;for(let e=0;e<this._data.scenes.length;e++){let r=this._data.scenes[e];if(isContainNode(r.nodes,t))return this._scenes[e]}return null}getAnimationPath(e,t){let r=[];if(e==t)return r;let a=t;for(;a.parent!=e;)a=a.parent,r.push(a.name);return r=r.reverse(),r.push(t.name),r}loadAnimations(e){e&&e.forEach(((e,t)=>{this.loadAnimation(e)}))}loadAnimation(e){return this.createAnimator(e)}createAnimator(e){let r=e.channels;e.samplers;let a=this.getAnimationRoot(r);if(!a)return null;let n=a.getComponent(t.Animator);if(!n){n=a.addComponent(t.Animator);let e=new t.AnimatorControllerLayer("AnimatorLayer");n.addControllerLayer(e),e.defaultWeight=1}let s=this.createAnimatorClip(e,a),l=n.getControllerLayer(),o=s.name;l.getAnimatorState(o)&&(o=s.name=`${o}_${this.generateId(o)}`);let i=new t.AnimatorState;return i.name=o,i.clip=s,l.addState(i),l.defaultState=i,l.playOnWake=!0,n}createAnimatorClip(e,r){let a=new t.AnimationClip,n=0,s=e.channels,l=e.samplers,o=[];s.forEach(((e,a)=>{var s;let i=e.target,u=l[e.sampler],h=i.path,c=this.getBufferwithAccessorIndex(u.input),d=this.getBufferwithAccessorIndex(u.output),m=new Float32Array(c),f=new Float32Array(d),p=this._nodes[i.node],g=this.getAnimationPath(r,p);if("weights"==h){let e=null===(s=p.getComponent(t.MeshFilter))||void 0===s?void 0:s.sharedMesh;if(e&&e.morphTargetData){let r=p.getComponent(t.SkinnedMeshRenderer)?"SkinnedMeshRenderer":"MeshRenderer",a=e.morphTargetData,s=a.channelCount;if(f.length/m.length==s)for(let e=0;e<s;e++){let t=a.getMorphChannelbyIndex(e).name,l={};o.push(l),l.paths=g,l.interpolation=u.interpolation,l.timeArray=m,l.valueArray=new Float32Array(m.length);for(let t=0;t<m.length;t++)l.valueArray[t]=f[t*s+e];l.propertyOwner=r,l.propertise=[],l.propertise.push("morphTargetValues"),l.propertise.push(t),l.propertyLength=l.propertise.length,l.type=0,l.callbackFunc="_changeMorphTargetValue",l.callbackParams=[t],l.propertyChangePath="morphTargetValues",l.duration=l.timeArray[l.timeArray.length-1],n=Math.max(n,l.duration)}}}else{let e={};o.push(e),e.timeArray=m,e.valueArray=f;let t=u.interpolation;switch(e.interpolation=t,e.paths=g,h){case"translation":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localPosition"),e.type=1;break;case"rotation":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localRotation"),e.type=2;break;case"scale":e.propertyOwner="transform",e.propertyLength=1,e.propertise=[],e.propertise.push("localScale"),e.type=3}e.duration=e.timeArray[e.timeArray.length-1],n=Math.max(n,e.duration)}})),a.name=e.name?e.name:`Animation_${this.generateId("Animation")}`,a._duration=n,a.islooping=!0,a._frameRate=30;let i=o.length,u=a._nodes;u.count=i;let h=a._nodesMap={},c=a._nodesDic={};for(let e=0;e<i;e++){let r=new t.KeyframeNode,a=o[e];u.setNodeByIndex(e,r),r._indexInList=e;let n=r.type=a.type,s=a.paths.length;r._setOwnerPathCount(s);let l=a.paths;for(let e=0;e<s;e++)r._setOwnerPathByIndex(e,l[e]);let i=r._joinOwnerPath("/"),d=h[i];d||(h[i]=d=[]),d.push(r),r.propertyOwner=a.propertyOwner;let m=a.propertyLength;r._setPropertyCount(m);for(let e=0;e<m;e++)r._setPropertyByIndex(e,a.propertise[e]);let f=i+"."+r.propertyOwner+"."+r._joinProperty(".");c[f]=f,r.fullPath=f,r.callbackFunData=a.callbackFunc,r.callParams=a.callbackParams,r.propertyChangePath=a.propertyChangePath;let p=a.timeArray.length;for(let e=0;e<p;e++)switch(n){case 0:let n=new t.FloatKeyframe;switch(r._setKeyframeByIndex(e,n),n.time=a.timeArray[e],a.interpolation){case"CUBICSPLINE":n.value=a.valueArray[3*e+1],n.inTangent=a.valueArray[3*e+0],n.outTangent=a.valueArray[3*e+2];break;case"STEP":n.value=a.valueArray[e],n.inTangent=1/0,n.outTangent=1/0;break;default:{n.value=a.valueArray[e];let t=0==e?e:e-1,r=a.timeArray[t],s=a.valueArray[t],l=t==e?1:n.time-r;n.inTangent=(n.value-s)/l;let o=e==p-1?e:e+1,i=a.timeArray[o],u=a.valueArray[o],h=o==e?1:i-n.time;n.outTangent=(u-n.value)/h,t==e&&(n.inTangent=n.outTangent),o==e&&(n.outTangent=n.inTangent)}}break;case 1:case 3:case 4:let s=new t.Vector3Keyframe;r._setKeyframeByIndex(e,s);let l=s.time=a.timeArray[e],o=s.inTangent,i=s.outTangent,u=s.value;switch(a.interpolation){case"CUBICSPLINE":u.setValue(a.valueArray[9*e+3],a.valueArray[9*e+4],a.valueArray[9*e+5]),o.setValue(a.valueArray[9*e+0],a.valueArray[9*e+1],a.valueArray[9*e+2]),i.setValue(a.valueArray[9*e+6],a.valueArray[9*e+7],a.valueArray[9*e+8]);break;case"STEP":u.setValue(a.valueArray[3*e],a.valueArray[3*e+1],a.valueArray[3*e+2]),o.setValue(1/0,1/0,1/0),i.setValue(1/0,1/0,1/0);break;default:{u.setValue(a.valueArray[3*e],a.valueArray[3*e+1],a.valueArray[3*e+2]);let t=0==e?e:e-1,r=a.timeArray[t],n=a.valueArray[3*t],s=a.valueArray[3*t+1],h=a.valueArray[3*t+2],c=t==e?1:l-r;o.x=(u.x-n)/c,o.y=(u.y-s)/c,o.z=(u.z-h)/c;let d=e==p-1?e:e+1,m=a.timeArray[d],f=a.valueArray[3*d],g=a.valueArray[3*d+1],x=a.valueArray[3*d+2],_=d==e?1:m-l;i.x=(f-u.x)/_,i.y=(g-u.y)/_,i.z=(x-u.z)/_,t==e&&i.cloneTo(o),d==e&&o.cloneTo(i)}}break;case 2:let h=new t.QuaternionKeyframe;r._setKeyframeByIndex(e,h);let c=h.time=a.timeArray[e],d=h.inTangent,m=h.outTangent,f=h.value;switch(a.interpolation){case"CUBICSPLINE":f.set(a.valueArray[12*e+4],a.valueArray[12*e+5],a.valueArray[12*e+6],a.valueArray[12*e+7]),d.setValue(a.valueArray[12*e+0],a.valueArray[12*e+1],a.valueArray[12*e+2],a.valueArray[12*e+3]),m.setValue(a.valueArray[12*e+8],a.valueArray[12*e+9],a.valueArray[12*e+10],a.valueArray[12*e+11]);break;case"STEP":f.set(a.valueArray[4*e+0],a.valueArray[4*e+1],a.valueArray[4*e+2],a.valueArray[4*e+3]),d.setValue(1/0,1/0,1/0,1/0),m.setValue(1/0,1/0,1/0,1/0);break;default:{f.set(a.valueArray[4*e+0],a.valueArray[4*e+1],a.valueArray[4*e+2],a.valueArray[4*e+3]);let t=0==e?e:e-1,r=a.timeArray[t],n=a.valueArray[4*t],s=a.valueArray[4*t+1],l=a.valueArray[4*t+2],o=a.valueArray[4*t+3],i=t==e?1:c-r;d.x=(f.x-n)/i,d.y=(f.y-s)/i,d.z=(f.z-l)/i,d.w=(f.w-o)/i;let u=e==p-1?e:e+1,h=a.timeArray[u],g=a.valueArray[4*u],x=a.valueArray[4*u+1],_=a.valueArray[4*u+2],T=a.valueArray[4*u+3];f.x*g+f.y*x+f.z*_+f.w*T<0&&(g*=-1,x*=-1,_*=-1,T*=-1,a.valueArray[4*u]=g,a.valueArray[4*u+1]=x,a.valueArray[4*u+2]=_,a.valueArray[4*u+3]=T);let A=u==e?1:h-c;m.x=(g-f.x)/A,m.y=(x-f.y)/A,m.z=(_-f.z)/A,m.w=(T-f.w)/A,t==e&&m.cloneTo(d),u==e&&d.cloneTo(m)}}}}return o=null,a}}glTFResource._Extensions={};class PrimitiveSubMesh{constructor(){}}t.Laya.onInitModule((()=>{glTFShader.init()}));const r="KHR_materials_anisotropy";class KHR_materials_anisotropy{constructor(e){this.name=r,this._resource=e}loadTextures(e,t){let r=this._resource.data.materials,a=this._resource.data.textures;if(r&&a){let a=[];return r.forEach((r=>{var n;let s=null===(n=r.extensions)||void 0===n?void 0:n.KHR_materials_anisotropy;if(s&&s.anisotropyTexture){let r=s.anisotropyTexture.index,n=this._resource.loadTextureFromglTF(r,!1,e,t);a.push(n)}})),Promise.all(a)}return Promise.resolve()}additionMaterialProperties(e,r){var a,n;let s=e.extensions.KHR_materials_anisotropy,l=null!==(a=s.anisotropyStrength)&&void 0!==a?a:0,o=null!==(n=s.anisotropyRotation)&&void 0!==n?n:0;if(r.setDefine(t.PBRShaderLib.DEFINE_ANISOTROPY,!0),r.setFloat("u_AnisotropyStrength",l),r.setFloat("u_AnisotropyRotation",o),s.anisotropyTexture){let e=this._resource.getTextureWithInfo(s.anisotropyTexture);r.setTexture("u_AnisotropyTexture",e),r.setDefine(glTFShader.Define_AnisotropyMap,!0)}}}glTFResource.registerExtension(r,(e=>new KHR_materials_anisotropy(e)));const a="KHR_materials_clearcoat";class KHR_materials_clearcoat{constructor(e){this.name=a,this._resource=e}loadTextures(e,t){let r=this._resource.data.materials,a=this._resource.data.textures;if(r&&a){let a=[];return r.forEach((r=>{var n;let s=null===(n=r.extensions)||void 0===n?void 0:n.KHR_materials_clearcoat;if(s){if(s.clearcoatTexture){let r=s.clearcoatTexture.index,n=this._resource.loadTextureFromglTF(r,!1,e,t);a.push(n)}if(s.clearcoatRoughnessTexture){let r=s.clearcoatRoughnessTexture.index,n=this._resource.loadTextureFromglTF(r,!1,e,t);a.push(n)}if(s.clearcoatNormalTexture){let r=s.clearcoatNormalTexture.index,n=this._resource.loadTextureFromglTF(r,!1,e,t);a.push(n)}}})),Promise.all(a)}return Promise.resolve()}additionMaterialProperties(e,r){var a,n,s;let l=e.extensions.KHR_materials_clearcoat,o=null!==(a=l.clearcoatFactor)&&void 0!==a?a:0,i=null!==(n=l.clearcoatRoughnessFactor)&&void 0!==n?n:0;if(r.setDefine(t.PBRShaderLib.DEFINE_CLEARCOAT,!0),r.setFloat("u_ClearCoatFactor",o),l.clearcoatTexture){let e=this._resource.getTextureWithInfo(l.clearcoatTexture);r.setTexture("u_ClearCoatTexture",e),r.setDefine(glTFShader.Define_ClearCoatMap,!0)}if(r.setFloat("u_ClearCoatRoughness",i),l.clearcoatRoughnessTexture){let e=this._resource.getTextureWithInfo(l.clearcoatRoughnessTexture);r.setTexture("u_ClearCoatRoughnessTexture",e),r.setDefine(glTFShader.Define_ClearCoatRoughnessMap,!0)}if(l.clearcoatNormalTexture){let e=this._resource.getTextureWithInfo(l.clearcoatNormalTexture);r.setTexture("u_ClearCoatNormalTexture",e),r.setDefine(glTFShader.Define_ClearCoatNormalMap,!0);let t=null!==(s=l.clearcoatNormalTexture.scale)&&void 0!==s?s:1;r.setFloat("u_ClearCoatNormalScale",t)}}}glTFResource.registerExtension(a,(e=>new KHR_materials_clearcoat(e)));const n="KHR_materials_emissive_strength";class KHR_materials_emissive_strength{constructor(e){this.name=n,this._resource=e}additionMaterialProperties(e,t){var r;let a=null!==(r=e.extensions.KHR_materials_emissive_strength.emissiveStrength)&&void 0!==r?r:1;t.setFloat("u_EmissionStrength",a)}}glTFResource.registerExtension(n,(e=>new KHR_materials_emissive_strength(e)));const s="KHR_materials_unlit";class KHR_materials_unlit{constructor(e){this.name=s,this._resource=e}createMaterial(e){let r=new t.UnlitMaterial,a=e.pbrMetallicRoughness;if(a){if(a.baseColorFactor){let e=r.albedoColor;e.fromArray(a.baseColorFactor),e.toGamma(e),r.albedoColor=e}a.baseColorTexture&&(r.albedoTexture=this._resource.getTextureWithInfo(a.baseColorTexture))}return this._resource.applyMaterialRenderState(e,r),r}}glTFResource.registerExtension(s,(e=>new KHR_materials_unlit(e)));t.Loader.registerLoader(["gltf"],class{load(e){return e.loader.fetch(e.url,"json",e.progress.createCallback(.5),e.options).then((t=>{let r=new glTFResource;return r._parse(t,e.url,e.progress).then((()=>r))}))}});t.Loader.registerLoader(["glb"],class{load(e){return e.loader.fetch(e.url,"arraybuffer",e.progress.createCallback(.5),e.options).then((t=>{let r=new glTFResource;return r._parseglb(t,e.url,e.progress).then((()=>r))}))}}),e.KHR_materials_anisotropy=KHR_materials_anisotropy,e.KHR_materials_clearcoat=KHR_materials_clearcoat,e.KHR_materials_emissive_strength=KHR_materials_emissive_strength,e.KHR_materials_unlit=KHR_materials_unlit,e.glTFResource=glTFResource,e.glTFShader=glTFShader}(window.Laya=window.Laya||{},Laya);
//# sourceMappingURL=laya.gltf.js.map