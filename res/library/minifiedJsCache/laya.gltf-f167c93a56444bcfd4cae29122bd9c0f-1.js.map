{"version":3,"names":["glTFShader","static","this","Define_BaseMap","Shader3D","getDefineByName","Define_MetallicRoughnessMap","Define_NormalMap","Define_OcclusionMap","Define_EmissionMap","Define_ClearCoatMap","Define_ClearCoatRoughnessMap","Define_ClearCoatNormalMap","Define_AnisotropyMap","find","name","uniformMap","u_AlphaTestValue","ShaderDataType","Float","u_BaseColorFactor","Vector4","u_BaseColorTexture","Texture2D","u_MetallicFactor","u_RoughnessFactor","u_MetallicRoughnessTexture","u_NormalTexture","u_NormalScale","u_OcclusionTexture","u_OcclusionStrength","u_EmissionFactor","Vector3","u_EmissionTexture","u_EmissionStrength","u_ClearCoatFactor","u_ClearCoatTexture","u_ClearCoatRoughness","u_ClearCoatRoughnessTexture","u_ClearCoatNormalTexture","u_ClearCoatNormalScale","u_AnisotropyStrength","u_AnisotropyRotation","u_AnisotropyTexture","defaultValue","ONE","ZERO","shader","add","subShader","SubShader","DefaultAttributeMap","addSubShader","addShaderPass","ShaderName","glTFResource","Prefab","constructor","super","_buffers","_textures","_materials","_meshes","_extensions","_pendingOps","_scenes","_nodes","factory","_Extensions","data","_data","loadBinary","basePath","progress","buffers","promises","forEach","buffer","i","Base64Tool","isBase64String","uri","bin","decode","replace","reghead","j","push","ILaya","loader","fetch","URL","join","createCallback","then","Promise","all","resolve","loadTextureFromglTF","index","sRGB","tex","textures","imgSource","source","glTFImg","images","samplerSource","sampler","glTFSampler","samplers","undefined","constructParams","getTextureConstructParams","propertyParams","getTexturePropertyParams","bufferView","bufferViews","byteOffset","byteLength","arraybuffer","slice","loadTextureFromBuffer","mimeType","res","addDep","loadTexture","loadTextures","materials","glTFMaterial","pbrMetallicRoughness","baseColorTexture","promise","metallicRoughnessTexture","normalTexture","occlusionTexture","emissiveTexture","extension","importMaterials","glTFMat","mat","createMaterial","importMeshes","meshes","nodes","glTFNode","mesh","glTFMesh","glTFSkin","_a","skins","skin","key","createMesh","_parse","createURL","asset","version","Error","getPath","_idCounter","extensionsUsed","value","extensionFactory","console","warn","length","_parseglb","byte","Byte","readUint32","firstChunkLength","firstChunkData","readArrayBuffer","jsonStr","TextDecoder","glTFObj","JSON","parse","chunkLength","firstBuffer","Math","min","_b","create","loadNodes","buildHierarchy","loadScenes","scenes","loadAnimations","animations","defaultSceneIndex","scene","defaultScene","url","encode","load","Loader","TEXTURE2D","generateId","context","toString","getAccessorComponentsNum","type","getAttributeNum","attriStr","_getTypedArrayConstructor","componentType","Int8Array","Uint8Array","Int16Array","Uint16Array","Uint32Array","Float32Array","_getAccessorDateByteStride","getBufferFormBufferView","accessorType","count","componentCount","byteStride","vertexStride","dataByteStride","dataStride","elementOffset","dataReader","resIndex","componentOffset","getBufferwithAccessorIndex","accessorIndex","accessor","accessors","accessorDataCount","fill","sparse","sparseCount","sparseIndices","indices","sparseIndicesBufferView","sparseIndicesData","sparseValues","values","sparseValuesBufferView","sparseValuesData","componentIndex","getTextureMipmap","minFilter","getTextureFormat","glTFImage","getTextureFilterMode","magFilter","getTextureWrapMode","mode","filterMode","wrapModeU","wrapS","wrapModeV","wrapT","anisoLevel","hdrEncodeFormat","HDREncodeFormat","NONE","getTextureWithInfo","glTFTextureInfo","texCoord","applyMaterialRenderState","material","alphaMode","materialRenderMode","MaterialRenderMode","RENDERMODE_OPAQUE","RENDERMODE_TRANSPARENT","RENDERMODE_CUTOUT","alphaTestValue","alphaCutoff","doubleSided","cull","RenderState","CULL_NONE","applyDefaultMaterialProperties","baseColorFactor","getVector4","fromArray","setVector4","setTexture","setDefine","metallicFactor","setFloat","roughnessFactor","normalScale","_c","scale","strength","_d","emissiveFactor","emissionFactor","getVector3","setVector3","PBRShaderLib","DEFINE_EMISSION","createDefaultMaterial","Material","setShaderName","propertiesExts","extensions","additionMaterialProperties","pickMeshMaterials","primitives","primitive","PBRStandardMaterial","indexOf","glTFScenes","glTFScene","_loadScene","_createSceneNode","glTFSceneNode","Sprite3D","nodeIndex","sprite","addChild","applyTransform","matrix","localMatrix","transform","elements","set","localPosition","localRotation","localScale","translation","rotation","glTFNodes","children","childIndex","child","SkinnedMeshSprite3D","fixSkinnedSprite","loadNode","createSprite3D","createSkinnedMeshSprite3D","createMeshSprite3D","storeId","_extra","MeshSprite3D","meshRenderer","sharedMaterials","receiveShadow","castShadow","weights","render","weight","target","morphTargetData","getMorphChannelbyIndex","setMorphChannelWeight","skinnedMeshRenderer","getArrributeBuffer","attributeAccessorIndex","layaDeclarStr","attributeMap","vertexDeclarArr","attributeBuffer","getIndexBuffer","vertexCount","indexBuffer","reverse","calculateFlatNormal","positions","indexArray","normal","i0","i1","i2","p0x","p0y","p0z","x1","y1","z1","x2","y2","z2","yz","xz","xy","invPyth","sqrt","nx","ny","nz","parseMeshwithSubMeshData","subDatas","layaMesh","vertexDecler","indexCount","subData","vertexDeclaration","VertexMesh","getVertexDeclaration","vertexFloatStride","vertexArray","ibFormat","IndexFormat","UInt32","UInt16","fillMeshBuffers","generateMesh","ibPosOffset","ibVertexOffset","vbPosOffset","iAOffset","subIb","fillAttributeBuffer","attriOffset","attriFloatCount","startOffset","ac","position","get","color","uv","uv1","blendWeight","blendIndices","blendIndicesUint8","tangent","splitSubMeshByBonesCount","morphtargets","boneIndicesList","subIndexStartArray","subIndexCountArray","start","subIndexSet","Set","boneIndexArray","resArray","flagArray","Array","n","triangleSet","boneIndexOffset","k","tempSet","size","curBoneList","from","drawCount","newAttributeMap","Map","array","newTargetMap","targets","newMap","attri","curMaxIndex","d","l","bl","batchFlag","batchMap","area","ci","biStart","cbi","oldBoneIndex","newBoneIndex","attOffset","oldArray","oldMap","oldFloatArray","newLength","newFloatArray","vertexBuffer","LayaGL","renderOBJCreate","createVertexBuffer3D","BufferUsage","Static","setData","createIndexBuffer3D","_indexFormat","_indexBuffer","_vertexBuffer","_setBuffer","_vertexCount","_byteLength","reCalculateBounds","Number","MAX_VALUE","max","subMeshOffset","subMeshCount","subMeshes","subMesh","SubMesh","subIndexStart","subIndexCount","_setIndexRange","_boneIndicesList","_subIndexBufferStart","_subIndexBufferCount","subIndex","boundMax","boundMin","x","y","z","_setSubMeshes","calculateBounds","bounds","setMin","setMax","memorySize","_setCPUMemory","_setGPUMemory","applyglTFSkinData","joints","inverseBindMatricesArray","inverseBindMatrices","boneCount","boneNames","_boneNames","node","_inverseBindPoses","_inverseBindPosesBuffer","bindPosesArrayOffset","matElement","Matrix4x4","subCount","skinnedCache","_skinnedMatrixCaches","submesh","getSubMesh","drawIndex","boneIndices","bni","bn","skinnedMatrixCache","applyMorphTarget","hasPosition","hasNormal","hasTangent","morphData","MorphTargetData","decStr","morphVertexDec","toLocaleString","targetVertexFloatStride","vertexDec","getMin","getMax","subVertexOffset","targetName","channel","getMorphChannel","MorphTargetChannel","MorphTarget","addTarget","addMorphChannel","getTargetByIndex","morphMap","vertexIndex","morphPosition","offset","getVertexElementByUsage","MESH_POSITION0","morphNormal","MESH_NORMAL0","morphTangent","MESH_TANGENT0","initData","Mesh","glTFMeshPrimitives","morphWeights","glTFMeshPrimitive","attributes","POSITION","positionAccessor","NORMAL","COLOR_0","TEXCOORD_0","TEXCOORD_1","WEIGHTS_0","JOINTS_0","TANGENT","tangentIndex","morphtargetMap","targetNames","extras","morph","morphX","morphY","morphZ","bi","PrimitiveSubMesh","calSkinnedSpriteLocalBounds","skinned","meshFilter","sharedMesh","oriRootMatrix","rootBone","worldMatrix","invertRootMatrix","invert","getIndices","boneWeights","getPositions","getBoneIndices","getBoneWeights","oriBoneIndeices","_subMeshes","bonelist","listIndex","endIndex","iindex","ii","boneIndex","w","inverseBindPoses","bones","ubones","tempMat","bone","multiply","skinTransform","resPos","pos","boneWeight","ei","transformV3ToV3","localBounds","skeleton","getAnimationRoot","channels","isContainNode","nodeArr","findNodeIndex","spriteIndex","getAnimationPath","root","curSprite","paths","parent","animation","loadAnimation","createAnimator","animatorRoot","animator","getComponent","Animator","addComponent","animatorLayer","AnimatorControllerLayer","addControllerLayer","defaultWeight","clip","createAnimatorClip","getControllerLayer","animationName","getAnimatorState","animatorState","AnimatorState","addState","defaultState","playOnWake","AnimationClip","duration","clipNodes","targetPath","path","timeBuffer","input","outBuffer","output","timeArray","outArray","animaPaths","MeshFilter","ownerStr","SkinnedMeshRenderer","channelCount","channelIndex","channelName","clipNode","interpolation","valueArray","propertyOwner","propertise","propertyLength","callbackFunc","callbackParams","propertyChangePath","_duration","islooping","_frameRate","nodeCount","nodesMap","_nodesMap","nodesDic","_nodesDic","KeyframeNode","glTFClipNode","setNodeByIndex","_indexInList","pathLength","_setOwnerPathCount","tempPath","_setOwnerPathByIndex","nodePath","_joinOwnerPath","mapArray","_setPropertyCount","_setPropertyByIndex","fullPath","_joinProperty","callbackFunData","callParams","keyframeCount","floatKeyFrame","FloatKeyframe","_setKeyframeByIndex","time","inTangent","outTangent","Infinity","lastI","lastTime","lastValue","lastTimeDet","nextI","nextTime","nextValue","nextTimeDet","floatArrayKeyframe","Vector3Keyframe","startTimev3","setValue","lastX","lastY","lastZ","nextX","nextY","nextZ","nestTimeDet","cloneTo","quaternionKeyframe","QuaternionKeyframe","startTimeQu","inTangentQua","outTangentQua","valueQua","lastW","nextW","Laya","onInitModule","init","ExtensionName","KHR_materials_anisotropy","resource","_resource","anisotropyTexture","anisotropy","anisotropyStrength","anisotropyRotation","DEFINE_ANISOTROPY","registerExtension","KHR_materials_clearcoat","clearcoatTexture","clearcoatRoughnessTexture","clearcoatNormalTexture","clearCoat","clearcoatFactor","clearCoatRoughness","clearcoatRoughnessFactor","DEFINE_CLEARCOAT","KHR_materials_emissive_strength","emissionStrength","emissiveStrength","KHR_materials_unlit","unlit","UnlitMaterial","albedoColor","toGamma","albedoTexture","registerLoader","task","options","glTF"],"sources":["../../src/layaAir/laya/gltf/shader/glTFShader.ts","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBR.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepth.fs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.vs","../../bin/tsc/layaAir/laya/gltf/shader/glTFPBRDepthNormal.fs","../../src/layaAir/laya/gltf/glTFResource.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_anisotropy.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_clearcoat.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_emissive_strength.ts","../../src/layaAir/laya/gltf/extensions/KHR_materials_unlit.ts","../../src/layaAir/laya/gltf/glTFLoader.ts"],"sourcesContent":["import { Shader3D } from \"../../RenderEngine/RenderShader/Shader3D\";\r\nimport { ShaderDataType } from \"../../RenderEngine/RenderShader/ShaderData\";\r\nimport { ShaderDefine } from \"../../RenderEngine/RenderShader/ShaderDefine\";\r\nimport { SubShader } from \"../../RenderEngine/RenderShader/SubShader\";\r\nimport { Vector3 } from \"../../maths/Vector3\";\r\nimport { Vector4 } from \"../../maths/Vector4\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\n\r\nimport glTFPBRVS from \"./glTFPBR.vs\";\r\nimport glTFPBRFS from \"./glTFPBR.fs\";\r\nimport DepthVS from \"./glTFPBRDepth.vs\";\r\nimport DephtFS from \"./glTFPBRDepth.fs\";\r\nimport DepthNormalVS from \"./glTFPBRDepthNormal.vs\";\r\nimport DepthNormalFS from \"./glTFPBRDepthNormal.fs\";\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFShader {\r\n\r\n    static ShaderName: string = \"glTFPBR\";\r\n\r\n    static Define_BaseMap: ShaderDefine;\r\n\r\n    static Define_MetallicRoughnessMap: ShaderDefine;\r\n\r\n    static Define_NormalMap: ShaderDefine;\r\n\r\n    static Define_OcclusionMap: ShaderDefine;\r\n\r\n    static Define_EmissionMap: ShaderDefine;\r\n\r\n    // clear coat\r\n    static Define_ClearCoatMap: ShaderDefine;\r\n    static Define_ClearCoatRoughnessMap: ShaderDefine;\r\n    static Define_ClearCoatNormalMap: ShaderDefine;\r\n\r\n    // anisotropy\r\n    static Define_AnisotropyMap: ShaderDefine;\r\n\r\n    // todo\r\n    static init() {\r\n        this.Define_BaseMap = Shader3D.getDefineByName(\"BASECOLORMAP\");\r\n        this.Define_MetallicRoughnessMap = Shader3D.getDefineByName(\"METALLICROUGHNESSMAP\");\r\n        this.Define_NormalMap = Shader3D.getDefineByName(\"NORMALMAP\");\r\n        this.Define_OcclusionMap = Shader3D.getDefineByName(\"OCCLUSIONMAP\");\r\n        this.Define_EmissionMap = Shader3D.getDefineByName(\"EMISSIONMAP\");\r\n\r\n        this.Define_ClearCoatMap = Shader3D.getDefineByName(\"CLEARCOATMAP\");\r\n        this.Define_ClearCoatRoughnessMap = Shader3D.getDefineByName(\"CLEARCOAT_ROUGHNESSMAP\");\r\n        this.Define_ClearCoatNormalMap = Shader3D.getDefineByName(\"CLEARCOAT_NORMAL\");\r\n\r\n        this.Define_AnisotropyMap = Shader3D.getDefineByName(\"ANISOTROPYMAP\");\r\n\r\n        let s = Shader3D.find(glTFShader.name);\r\n        if (s) {\r\n            return;\r\n        }\r\n\r\n        let uniformMap = {\r\n            // render \r\n            \"u_AlphaTestValue\": ShaderDataType.Float,\r\n            // surface\r\n            // metallic roughness\r\n            \"u_BaseColorFactor\": ShaderDataType.Vector4,\r\n            \"u_BaseColorTexture\": ShaderDataType.Texture2D,\r\n            \"u_MetallicFactor\": ShaderDataType.Float,\r\n            \"u_RoughnessFactor\": ShaderDataType.Float,\r\n            \"u_MetallicRoughnessTexture\": ShaderDataType.Texture2D,\r\n\r\n            \"u_NormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_NormalScale\": ShaderDataType.Float,\r\n\r\n            \"u_OcclusionTexture\": ShaderDataType.Texture2D,\r\n            \"u_OcclusionStrength\": ShaderDataType.Float,\r\n\r\n            \"u_EmissionFactor\": ShaderDataType.Vector3,\r\n            \"u_EmissionTexture\": ShaderDataType.Texture2D,\r\n            \"u_EmissionStrength\": ShaderDataType.Float,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": ShaderDataType.Float,\r\n            \"u_ClearCoatTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatRoughness\": ShaderDataType.Float,\r\n            \"u_ClearCoatRoughnessTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatNormalTexture\": ShaderDataType.Texture2D,\r\n            \"u_ClearCoatNormalScale\": ShaderDataType.Float,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": ShaderDataType.Float,\r\n            \"u_AnisotropyRotation\": ShaderDataType.Float,\r\n            \"u_AnisotropyTexture\": ShaderDataType.Texture2D,\r\n        }\r\n\r\n        let defaultValue = {\r\n            // render \r\n            \"u_AlphaTestValue\": 0.5,\r\n            // surface\r\n            \"u_BaseColorFactor\": Vector4.ONE,\r\n            \"u_MetallicFactor\": 1.0,\r\n            \"u_RoughnessFactor\": 1.0,\r\n            \"u_NormalScale\": 1.0,\r\n            \"u_OcclusionStrength\": 1.0,\r\n            \"u_EmissionFactor\": Vector3.ZERO,\r\n            \"u_EmissionStrength\": 1.0,\r\n\r\n            // clear coat\r\n            \"u_ClearCoatFactor\": 0.0,\r\n            \"u_ClearCoatRoughness\": 0.0,\r\n            \"u_ClearCoatNormalScale\": 1.0,\r\n\r\n            // anisotropy\r\n            \"u_AnisotropyStrength\": 0.0,\r\n            \"u_AnisotropyRotation\": 0.0\r\n        }\r\n\r\n        let shader = Shader3D.add(\"glTFPBR\", true, true);\r\n        let subShader = new SubShader(SubShader.DefaultAttributeMap, uniformMap, defaultValue);\r\n        shader.addSubShader(subShader);\r\n\r\n        let shadingPass = subShader.addShaderPass(glTFPBRVS, glTFPBRFS);\r\n        let depthPass = subShader.addShaderPass(DepthVS, DephtFS, \"ShadowCaster\");\r\n        let dephtNormalPass = subShader.addShaderPass(DepthNormalVS, DepthNormalFS, \"DepthNormal\");\r\n\r\n    }\r\n\r\n}","#define SHADER_NAME glTFPBRVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFogInput.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    gl_Position = getPositionCS(pixel.positionWS);\r\n\r\n    gl_Position = remapPositionZ(gl_Position);\r\n\r\n#ifdef FOG\r\n    FogHandle(gl_Position.z);\r\n#endif\r\n}","#define SHADER_NAME glTFPBRFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"PBRMetallicFrag.glsl\";\r\n\r\nvoid initSurfaceInputs(inout SurfaceInputs inputs, const in PixelParams pixel)\r\n{\r\n    vec2 uv = vec2(0.0);\r\n#ifdef UV\r\n    uv = pixel.uv0;\r\n#endif //\r\n\r\n    // render state\r\n    inputs.alphaTest = u_AlphaTestValue;\r\n\r\n    // surface\r\n    inputs.diffuseColor = u_BaseColorFactor.xyz;\r\n    inputs.alpha = u_BaseColorFactor.w;\r\n\r\n#ifdef COLOR\r\n    #ifdef ENABLEVERTEXCOLOR\r\n    inputs.diffuseColor *= pixel.vertexColor.xyz;\r\n    inputs.alpha *= pixel.vertexColor.a;\r\n    #endif // ENABLEVERTEXCOLOR\r\n#endif // COLOR\r\n\r\n#ifdef BASECOLORMAP\r\n    vec4 baseColorSampler = texture2D(u_BaseColorTexture, uv);\r\n#ifdef Gamma_u_BaseColorTexture\r\n    baseColorSampler = gammaToLinear(baseColorSampler);\r\n#endif // u_BaseColorTexture_Gamma\r\n    inputs.diffuseColor *= baseColorSampler.rgb;\r\n    inputs.alpha *= baseColorSampler.a;\r\n#endif // BASECOLORMAP\r\n\r\n    inputs.metallic = u_MetallicFactor;\r\n    float roughness = u_RoughnessFactor;\r\n#ifdef METALLICROUGHNESSMAP\r\n    vec4 metallicRoughnessSampler = texture2D(u_MetallicRoughnessTexture, uv);\r\n    inputs.metallic *= metallicRoughnessSampler.b;\r\n    roughness *= metallicRoughnessSampler.g;\r\n#endif // METALLICROUGHNESSMAP\r\n    inputs.smoothness = 1.0 - roughness;\r\n\r\n    float occlusion = 1.0;\r\n#ifdef OCCLUSIONMAP\r\n    vec4 occlusionSampler = texture2D(u_OcclusionTexture, uv);\r\n    #ifdef Gamma_u_OcclusionTexture\r\n    occlusionSampler = gammaToLinear(occlusionSampler);\r\n    #endif // Gamma_u_OcclusionTexture\r\n    occlusion = occlusionSampler.r;\r\n#endif // OCCLUSIONMAP\r\n    inputs.occlusion = (1.0 - u_OcclusionStrength) + occlusion * u_OcclusionStrength;\r\n\r\n    inputs.emissionColor = u_EmissionFactor * u_EmissionStrength;\r\n#ifdef EMISSIONMAP\r\n    vec4 emissionSampler = texture2D(u_EmissionTexture, uv);\r\n    #ifdef Gamma_u_EmissionTexture\r\n    emissionSampler = gammaToLinear(emissionSampler);\r\n    #endif // Gamma_u_EmissionTexture\r\n    inputs.emissionColor *= emissionSampler.rgb;\r\n#endif // EMISSIONMAP\r\n\r\n    inputs.normalTS = vec3(0.0, 0.0, 1.0);\r\n#ifdef NORMALMAP\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    inputs.normalTS = normalScale(normalSampler, u_NormalScale);\r\n#endif // NORMALMAP\r\n\r\n#ifdef CLEARCOAT\r\n    inputs.clearCoat = u_ClearCoatFactor;\r\n    inputs.clearCoatRoughness = u_ClearCoatRoughness;\r\n\r\n    #ifdef CLEARCOATMAP\r\n    vec4 clearCoatSampler = texture2D(u_ClearCoatTexture, uv);\r\n    inputs.clearCoat *= clearCoatSampler.r;\r\n    #endif // CLEARCOATMAP\r\n\r\n    #ifdef CLEARCOAT_ROUGHNESSMAP\r\n    vec4 clearcoatSampleRoughness = texture2D(u_ClearCoatRoughnessTexture, uv);\r\n    inputs.clearCoatRoughness *= clearcoatSampleRoughness.g;\r\n    #endif // CLEARCOAT_ROUGHNESSMAP\r\n\r\n    #ifdef CLEARCOAT_NORMAL\r\n    vec3 clearCoatNormalSampler = texture2D(u_ClearCoatNormalTexture, uv).rgb;\r\n    clearCoatNormalSampler = normalize(clearCoatNormalSampler * 2.0 - 1.0);\r\n    clearCoatNormalSampler.y *= -1.0;\r\n    // todo scale\r\n    inputs.clearCoatNormalTS = normalScale(clearCoatNormalSampler, u_ClearCoatNormalScale);\r\n    #endif // CLEARCOAT_NORMAL\r\n#endif // CLEARCOAT\r\n\r\n#ifdef ANISOTROPIC\r\n    inputs.anisotropy = u_AnisotropyStrength;\r\n    vec2 direction = vec2(1.0, 0.0);\r\n\r\n    #ifdef ANISOTROPYMAP\r\n    vec3 anisotropySampler = texture2D(u_AnisotropyTexture, uv).rgb;\r\n\r\n    inputs.anisotropy *= anisotropySampler.b;\r\n    direction = anisotropySampler.xy * 2.0 - 1.0;\r\n    #endif // ANISOTROPYMAP\r\n\r\n    vec2 anisotropyRotation = vec2(cos(u_AnisotropyRotation), sin(u_AnisotropyRotation));\r\n    mat2 rotationMatrix = mat2(anisotropyRotation.x, anisotropyRotation.y, -anisotropyRotation.y, anisotropyRotation.x);\r\n    inputs.anisotropyDirection = rotationMatrix * direction;\r\n\r\n#endif // ANISOTROPIC\r\n}\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    SurfaceInputs inputs;\r\n    initSurfaceInputs(inputs, pixel);\r\n\r\n    vec4 surfaceColor = PBR_Metallic_Flow(inputs, pixel);\r\n\r\n#ifdef FOG\r\n    surfaceColor.rgb = sceneLitFog(surfaceColor.rgb);\r\n#endif // FOG\r\n\r\n    gl_FragColor = surfaceColor;\r\n\r\n    gl_FragColor = outputTransform(gl_FragColor);\r\n\r\n    // // debug\r\n    // Surface surface;\r\n    // initSurface(surface, inputs, pixel);\r\n\r\n    // // PixelInfo info;\r\n    // // getPixelInfo(info, pixel, surface);\r\n\r\n    // vec3 debug = vec3(0.0);\r\n\r\n    // debug = vec3(1.0 - inputs.smoothness);\r\n\r\n    // debug = gammaToLinear(debug);\r\n    // gl_FragColor = vec4(debug, 1.0);\r\n}","#define SHADER_NAME glTFDepthVS\r\n\r\n#include \"DepthVertex.glsl\";\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    mat4 worldMat = getWorldMatrix();\r\n    vec4 pos = (worldMat * vec4(vertex.positionOS, 1.0));\r\n    vec3 positionWS = pos.xyz / pos.w;\r\n\r\n    mat4 normalMat = transpose(inverse(worldMat));\r\n    vec3 normalWS = normalize((normalMat * vec4(vertex.normalOS, 0.0)).xyz);\r\n\r\n    vec4 positionCS = DepthPositionCS(positionWS, normalWS);\r\n    gl_Position = remapPositionZ(positionCS);\r\n}","#define SHADER_NAME glTFDepthFS\r\n\r\n#include \"DepthFrag.glsl\";\r\n\r\nvoid main()\r\n{\r\n    gl_FragColor = getDepthColor();\r\n}","#define SHADER_NAME glTFPBRDepthNormalVS\r\n\r\n#include \"Math.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n\r\n#include \"Sprite3DVertex.glsl\";\r\n\r\n#include \"VertexCommon.glsl\";\r\n\r\n#include \"PBRVertex.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    Vertex vertex;\r\n    getVertexParams(vertex);\r\n\r\n    PixelParams pixel;\r\n    initPixelParams(pixel, vertex);\r\n\r\n    sharePixelParams(pixel);\r\n\r\n    vec4 positionCS = getPositionCS(pixel.positionWS);\r\n    v_PositionCS = positionCS;\r\n    gl_Position = positionCS;\r\n    gl_Position = remapPositionZ(gl_Position);\r\n}","#define SHADER_NAME glTFPBRDepthNormalFS\r\n\r\n#include \"Color.glsl\";\r\n\r\n#include \"Scene.glsl\";\r\n#include \"SceneFog.glsl\";\r\n\r\n#include \"Camera.glsl\";\r\n#include \"Sprite3DFrag.glsl\";\r\n\r\n#include \"ShadingFrag.glsl\";\r\n\r\n#include \"DepthNormalFrag.glsl\";\r\n\r\nvarying vec4 v_PositionCS;\r\n\r\nvoid main()\r\n{\r\n    PixelParams pixel;\r\n    getPixelParams(pixel);\r\n\r\n    vec3 normalWS = pixel.normalWS;\r\n\r\n#ifdef NORMALMAP\r\n    #ifdef UV\r\n\r\n    vec2 uv = pixel.uv0;\r\n\r\n    vec3 normalSampler = texture2D(u_NormalTexture, uv).xyz;\r\n    normalSampler = normalize(normalSampler * 2.0 - 1.0);\r\n    normalSampler.y *= -1.0;\r\n    vec3 normalTS = normalScale(normalSampler, u_NormalScale);\r\n    normalWS = normalize(pixel.TBN * normalTS);\r\n\r\n    #endif UV\r\n#endif // NORMALMAP\r\n\r\n    vec4 positionCS = v_PositionCS;\r\n\r\n    vec4 dephtNormal = encodeDepthNormal(positionCS, normalWS);\r\n\r\n    gl_FragColor = dephtNormal;\r\n}","import { AnimationClip } from \"../d3/animation/AnimationClip\";\r\nimport { KeyframeNode } from \"../d3/animation/KeyframeNode\";\r\nimport { KeyframeNodeList } from \"../d3/animation/KeyframeNodeList\";\r\nimport { Material, MaterialRenderMode } from \"../d3/core/material/Material\";\r\nimport { PBRStandardMaterial } from \"../d3/core/material/PBRStandardMaterial\";\r\nimport { Mesh, skinnedMatrixCache } from \"../d3/resource/models/Mesh\";\r\nimport { URL } from \"../net/URL\";\r\nimport { Texture2D, TextureConstructParams, TexturePropertyParams } from \"../resource/Texture2D\";\r\nimport * as glTF from \"./glTFInterface\";\r\n\r\nimport { ILaya } from \"../../ILaya\";\r\nimport { BufferUsage } from \"../RenderEngine/RenderEnum/BufferTargetType\";\r\nimport { HDREncodeFormat } from \"../RenderEngine/RenderEnum/HDREncodeFormat\";\r\nimport { IndexFormat } from \"../RenderEngine/RenderEnum/IndexFormat\";\r\nimport { RenderState } from \"../RenderEngine/RenderShader/RenderState\";\r\nimport { VertexMesh } from \"../RenderEngine/RenderShader/VertexMesh\";\r\nimport { VertexDeclaration } from \"../RenderEngine/VertexDeclaration\";\r\nimport { Animator } from \"../d3/component/Animator/Animator\";\r\nimport { AnimatorControllerLayer } from \"../d3/component/Animator/AnimatorControllerLayer\";\r\nimport { AnimatorState } from \"../d3/component/Animator/AnimatorState\";\r\nimport { FloatKeyframe } from \"../d3/core/FloatKeyframe\";\r\nimport { MeshFilter } from \"../d3/core/MeshFilter\";\r\nimport { MeshSprite3D } from \"../d3/core/MeshSprite3D\";\r\nimport { QuaternionKeyframe } from \"../d3/core/QuaternionKeyframe\";\r\nimport { SkinnedMeshRenderer } from \"../d3/core/SkinnedMeshRenderer\";\r\nimport { SkinnedMeshSprite3D } from \"../d3/core/SkinnedMeshSprite3D\";\r\nimport { Sprite3D } from \"../d3/core/Sprite3D\";\r\nimport { Vector3Keyframe } from \"../d3/core/Vector3Keyframe\";\r\nimport { IndexBuffer3D } from \"../d3/graphics/IndexBuffer3D\";\r\nimport { VertexBuffer3D } from \"../d3/graphics/VertexBuffer3D\";\r\nimport { MorphTarget, MorphTargetChannel } from \"../d3/resource/models/MorphTarget\";\r\nimport { MorphTargetData } from \"../d3/resource/models/MorphTargetData\";\r\nimport { SubMesh } from \"../d3/resource/models/SubMesh\";\r\nimport { Node } from \"../display/Node\";\r\nimport { LayaGL } from \"../layagl/LayaGL\";\r\nimport { Matrix4x4 } from \"../maths/Matrix4x4\";\r\nimport { Quaternion } from \"../maths/Quaternion\";\r\nimport { Vector3 } from \"../maths/Vector3\";\r\nimport { Vector4 } from \"../maths/Vector4\";\r\nimport { IBatchProgress } from \"../net/BatchProgress\";\r\nimport { Loader } from \"../net/Loader\";\r\nimport { Prefab } from \"../resource/HierarchyResource\";\r\nimport { Base64Tool } from \"../utils/Base64Tool\";\r\nimport { Byte } from \"../utils/Byte\";\r\nimport { glTFExtension } from \"./extensions/glTFExtension\";\r\nimport { glTFShader } from \"./shader/glTFShader\";\r\nimport { PBRShaderLib } from \"../d3/shader/pbr/PBRShaderLib\";\r\nimport { Laya } from \"../../Laya\";\r\n\r\nconst maxSubBoneCount = 24;\r\n\r\n/**\r\n * @internal\r\n */\r\nexport class glTFResource extends Prefab {\r\n\r\n    private static _Extensions: { [name: string]: (resource: glTFResource) => glTFExtension } = {};\r\n\r\n    static registerExtension(name: string, factory: (resource: glTFResource) => glTFExtension) {\r\n        this._Extensions[name] = factory;\r\n    }\r\n\r\n    protected _data: glTF.glTF;\r\n\r\n    get data(): Readonly<glTF.glTF> {\r\n        return this._data;\r\n    }\r\n\r\n    protected _buffers: Record<string, ArrayBuffer>;\r\n    protected _textures: Texture2D[];\r\n    protected _materials: Material[];\r\n    protected _meshes: Record<string, Mesh>;\r\n\r\n    protected _extensions: Array<glTFExtension>;\r\n\r\n    protected _pendingOps: Array<Promise<any>>;\r\n\r\n    private _scenes: Array<Sprite3D>;\r\n    private _nodes: Array<Sprite3D>;\r\n\r\n    /** @internal */\r\n    private _idCounter: Record<string, number>;\r\n\r\n    constructor() {\r\n        super(3);\r\n\r\n        this._buffers = {};\r\n        this._textures = [];\r\n        this._materials = [];\r\n        this._meshes = {};\r\n        this._extensions = [];\r\n        this._pendingOps = [];\r\n        this._scenes = [];\r\n        this._nodes = [];\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadBinary(basePath: string, progress?: IBatchProgress) {\r\n        let data = this._data;\r\n        if (data.buffers) {\r\n            let promises: Array<Promise<any>> = [];\r\n            data.buffers.forEach((buffer, i) => {\r\n                if (Base64Tool.isBase64String(buffer.uri)) {\r\n                    let bin = Base64Tool.decode(buffer.uri.replace(Base64Tool.reghead, \"\"));\r\n                    this._buffers[i] = bin;\r\n                }\r\n                else {\r\n                    let j = i;\r\n                    promises.push(ILaya.loader.fetch(URL.join(basePath, buffer.uri), \"arraybuffer\", progress?.createCallback(0.2))\r\n                        .then(bin => {\r\n                            this._buffers[j] = bin;\r\n                        }));\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    loadTextureFromglTF(index: number, sRGB: boolean, basePath: string, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let data = this._data;\r\n\r\n        let tex = data.textures[index];\r\n        let imgSource = tex.source;\r\n        let glTFImg = data.images[imgSource];\r\n        let samplerSource = tex.sampler;\r\n        let glTFSampler = data.samplers ? data.samplers[samplerSource] : undefined;\r\n\r\n        let constructParams = this.getTextureConstructParams(glTFImg, glTFSampler, sRGB);\r\n        let propertyParams = this.getTexturePropertyParams(glTFSampler);\r\n\r\n        if (glTFImg.bufferView != null) {\r\n            let bufferView = data.bufferViews[glTFImg.bufferView];\r\n            let buffer = this._buffers[bufferView.buffer];\r\n            let byteOffset = bufferView.byteOffset || 0;\r\n            let byteLength = bufferView.byteLength;\r\n\r\n            let arraybuffer = buffer.slice(byteOffset, byteOffset + byteLength);\r\n\r\n            return this.loadTextureFromBuffer(arraybuffer, glTFImg.mimeType, constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n        else {\r\n            return this.loadTexture(URL.join(basePath, glTFImg.uri), constructParams, propertyParams, progress).then(res => {\r\n                this._textures[index] = res;\r\n                this.addDep(res);\r\n                return res;\r\n            });\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param basePath \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let data = this._data;\r\n        let materials = data.materials;\r\n        let textures = data.textures;\r\n        let promises: Array<Promise<Texture2D>> = [];\r\n        if (materials && textures) {\r\n            for (let glTFMaterial of data.materials) {\r\n                let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n                if (pbrMetallicRoughness) {\r\n                    if (pbrMetallicRoughness.baseColorTexture) {\r\n                        let index = pbrMetallicRoughness.baseColorTexture.index;\r\n                        let sRGB = true;\r\n                        let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                        let index = pbrMetallicRoughness.metallicRoughnessTexture.index;\r\n                        let sRGB = false;\r\n                        let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n                if (glTFMaterial.normalTexture) {\r\n                    let index = glTFMaterial.normalTexture.index;\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.occlusionTexture) {\r\n                    let index = glTFMaterial.occlusionTexture.index;\r\n                    let sRGB = false;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n                if (glTFMaterial.emissiveTexture) {\r\n                    let index = glTFMaterial.emissiveTexture.index;\r\n                    let sRGB = true;\r\n                    let promise = this.loadTextureFromglTF(index, sRGB, basePath, progress);\r\n                    promises.push(promise);\r\n                }\r\n            }\r\n        }\r\n        this._extensions.forEach(extension => {\r\n            if (extension.loadTextures) {\r\n                let promise = extension.loadTextures(basePath, progress);\r\n                promises.push(promise);\r\n            }\r\n\r\n        });\r\n        return Promise.all(promises);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMaterials() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.materials) {\r\n                data.materials.forEach((glTFMat, index) => {\r\n                    let mat = this.createMaterial(glTFMat);\r\n                    this._materials[index++] = mat;\r\n                    this.addDep(mat);\r\n                })\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @returns \r\n     */\r\n    importMeshes() {\r\n        return Promise.resolve().then(() => {\r\n            let data = this._data;\r\n            if (data.meshes && data.nodes) {\r\n                data.nodes.forEach((glTFNode) => {\r\n                    if (glTFNode.mesh != null) {\r\n                        let glTFMesh = this._data.meshes[glTFNode.mesh];\r\n                        let glTFSkin = this._data.skins?.[glTFNode.skin];\r\n                        let key = glTFNode.mesh + (glTFNode.skin != null ? (\"_\" + glTFNode.skin) : \"\");\r\n                        let mesh = this._meshes[key];\r\n                        if (!mesh) {\r\n                            mesh = this.createMesh(glTFMesh, glTFSkin);\r\n                            this._meshes[key] = mesh;\r\n                            this.addDep(mesh);\r\n                        }\r\n                    }\r\n                });\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     * @returns \r\n     */\r\n    _parse(data: glTF.glTF, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        if (!data.asset || data.asset.version !== \"2.0\") {\r\n            throw new Error(\"glTF version wrong!\");\r\n        }\r\n\r\n        this._data = data;\r\n        let basePath = URL.getPath(createURL);\r\n        this._idCounter = {};\r\n\r\n        data.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.push(extensionFactory(this));\r\n            }\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadBinary(basePath, progress);\r\n\r\n        promise = promise.then(() => {\r\n            return this.loadTextures(basePath, progress);\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param data \r\n     * @param createURL \r\n     * @param progress \r\n     */\r\n    _parseglb(data: ArrayBuffer, createURL: string, progress?: IBatchProgress): Promise<void> {\r\n        let basePath = URL.getPath(createURL);\r\n        // let promise: Promise<any>;\r\n        this._idCounter = {};\r\n\r\n        let byte = new Byte(data);\r\n        let magic = byte.readUint32();\r\n        //  ASCII string glTF\r\n        if (magic != 0x46546C67) {\r\n            throw new Error(\"glb fromat wrong!\");\r\n        }\r\n\r\n        let version = byte.readUint32();\r\n        if (version != 2) {\r\n            throw new Error(\"glb version wrong!\");\r\n        }\r\n\r\n        // total length of the Binary glTF, including header and all chunks, in bytes.\r\n        let length = byte.readUint32();\r\n\r\n        /**\r\n         * first chunk: json \r\n         * second chunk: buffer\r\n         * other chunk: ignore\r\n         */\r\n\r\n        // first chunk json\r\n        let firstChunkLength = byte.readUint32();\r\n        let firstChunkType = byte.readUint32();\r\n        if (firstChunkType != 0x4E4F534A) {\r\n            throw new Error(\"glb json chunk data wrong!\");\r\n        }\r\n\r\n        let firstChunkData = byte.readArrayBuffer(firstChunkLength);\r\n        let texDecoder = new TextDecoder();\r\n        let jsonStr = texDecoder.decode(firstChunkData);\r\n        let glTFObj: glTF.glTF = JSON.parse(jsonStr);\r\n        this._data = glTFObj;\r\n\r\n        // binary data json\r\n        let chunkLength = byte.readUint32();\r\n        let chunkType = byte.readUint32();\r\n        if (chunkType != 0x004E4942) {\r\n            throw new Error(\"glb bin chunk data wrong!\");\r\n        }\r\n        let firstBuffer = glTFObj.buffers?.[0];\r\n        firstBuffer.byteLength = firstBuffer.byteLength ? (Math.min(firstBuffer.byteLength, chunkLength)) : chunkLength;\r\n\r\n        this._buffers[0] = byte.readArrayBuffer(firstBuffer.byteLength);\r\n\r\n        glTFObj.extensionsUsed?.forEach(value => {\r\n            let extensionFactory = glTFResource._Extensions[value];\r\n            if (!extensionFactory) {\r\n                console.warn(`glTF: unsupported extension: ${value}`);\r\n            }\r\n            else {\r\n                this._extensions.push(extensionFactory(this));\r\n            }\r\n            // this._extensions.sort((a, b) => )\r\n        });\r\n\r\n        let promise: Promise<any> = this.loadTextures(basePath, progress);\r\n        promise = promise.then(() => {\r\n            return this.importMeshes();\r\n        });\r\n\r\n        promise = promise.then(() => {\r\n            return this.importMaterials();\r\n        });\r\n\r\n        return promise.then(() => {\r\n            if (this._pendingOps.length > 0) {\r\n                return Promise.all(this._pendingOps).then(() => {\r\n                    this._idCounter = null;\r\n                });\r\n            }\r\n            else {\r\n                this._idCounter = null;\r\n                return Promise.resolve();\r\n            }\r\n        });\r\n    }\r\n\r\n    public create(): Node {\r\n        let data = this._data;\r\n\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = {};\r\n\r\n        this.loadNodes(data.nodes);\r\n        this.buildHierarchy(data.nodes);\r\n        this.loadScenes(data.scenes);\r\n        this.loadAnimations(data.animations);\r\n\r\n        let defaultSceneIndex = (data.scene != undefined) ? data.scene : 0;\r\n        let defaultScene: Sprite3D = this._scenes[defaultSceneIndex];\r\n        this._scenes.length = 0;\r\n        this._nodes.length = 0;\r\n        this._idCounter = null;\r\n\r\n        return defaultScene;\r\n    }\r\n\r\n    protected loadTextureFromBuffer(buffer: ArrayBuffer, mimeType: glTF.glTFImageMimeType, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        let base64: string = Base64Tool.encode(buffer);\r\n        let url: string = `data:${mimeType};base64,${base64}`;\r\n\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    protected loadTexture(url: string, constructParams: TextureConstructParams, propertyParams: TexturePropertyParams, progress?: IBatchProgress): Promise<Texture2D> {\r\n        return ILaya.loader.load({ url: url, constructParams: constructParams, propertyParams: propertyParams },\r\n            Loader.TEXTURE2D, progress?.createCallback());\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 node name\r\n     */\r\n    protected generateId(context: string): string {\r\n        let i = this._idCounter[context];\r\n        if (i == null)\r\n            i = 0;\r\n        else\r\n            i++;\r\n        this._idCounter[context] = i;\r\n        return i.toString();\r\n    }\r\n\r\n    /**\r\n     * 根据数据类型获取分量\r\n     * @param type \r\n     */\r\n    private getAccessorComponentsNum(type: glTF.glTFAccessorType): number {\r\n        switch (type) {\r\n            case \"SCALAR\": return 1;\r\n            case \"VEC2\": return 2;\r\n            case \"VEC3\": return 3;\r\n            case \"VEC4\": return 4;\r\n            case \"MAT2\": return 4;\r\n            case \"MAT3\": return 9;\r\n            case \"MAT4\": return 16;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 attribute 分量\r\n     * @param attriStr \r\n     */\r\n    private getAttributeNum(attriStr: string): number {\r\n        switch (attriStr) {\r\n            case \"POSITION\": return 3;\r\n            case \"NORMAL\": return 3;\r\n            case \"COLOR\": return 4;\r\n            case \"UV\": return 2;\r\n            case \"UV1\": return 2;\r\n            case \"BLENDWEIGHT\": return 4;\r\n            case \"BLENDINDICES\": return 4;\r\n            case \"TANGENT\": return 4;\r\n            default: return 0;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 buffer constructor\r\n     * @param componentType \r\n     */\r\n    private _getTypedArrayConstructor(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return Int8Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return Uint8Array;\r\n            case glTF.glTFAccessorComponentType.SHORT: return Int16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return Uint16Array;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return Uint32Array;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return Float32Array;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 accessor data Type byte stride\r\n     * @param componentType \r\n     */\r\n    _getAccessorDateByteStride(componentType: glTF.glTFAccessorComponentType) {\r\n        switch (componentType) {\r\n            case glTF.glTFAccessorComponentType.BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_BYTE: return 1;\r\n            case glTF.glTFAccessorComponentType.SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_SHORT: return 2;\r\n            case glTF.glTFAccessorComponentType.UNSIGNED_INT: return 4;\r\n            case glTF.glTFAccessorComponentType.FLOAT: return 4;\r\n        }\r\n    }\r\n\r\n    private getBufferFormBufferView(bufferView: glTF.glTFBufferView, byteOffset: number, accessorType: glTF.glTFAccessorType, componentType: glTF.glTFAccessorComponentType, count: number) {\r\n        let buffer: ArrayBuffer = this._buffers[bufferView.buffer];\r\n\r\n        const constructor = this._getTypedArrayConstructor(componentType);\r\n        let componentCount: number = this.getAccessorComponentsNum(accessorType);\r\n        let res;\r\n        if (bufferView.byteStride) {\r\n            let vertexStride = bufferView.byteStride;\r\n            let dataByteStride = this._getAccessorDateByteStride(componentType);\r\n            let dataStride = vertexStride / dataByteStride;\r\n\r\n            let elementByteOffset = byteOffset || 0;\r\n            let elementOffset = elementByteOffset / dataByteStride;\r\n\r\n            // let d = new ArrayBuffer(dataStride * accessorDataCount);\r\n            let dataReader = new constructor(buffer, bufferView.byteOffset || 0, bufferView.byteLength / dataByteStride);\r\n            res = new constructor(count);\r\n            let resIndex = 0;\r\n            for (let index = 0; index < count; index++) {\r\n                let componentOffset = index * dataStride;\r\n                for (let i = 0; i < componentCount; i++) {\r\n                    res[resIndex++] = dataReader[componentOffset + elementOffset + i];\r\n                }\r\n            }\r\n        }\r\n        else {\r\n            let bufferOffset: number = (bufferView.byteOffset || 0) + (byteOffset || 0);\r\n            res = new constructor(buffer, bufferOffset, count);\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 获取 accessor buffer 数据\r\n     * @param accessorIndex \r\n     */\r\n    private getBufferwithAccessorIndex(accessorIndex: number) {\r\n        let accessor: glTF.glTFAccessor = this._data.accessors[accessorIndex];\r\n        if (!accessor)\r\n            return null;\r\n\r\n        let count: number = accessor.count;\r\n        let componentCount: number = this.getAccessorComponentsNum(accessor.type);\r\n        let accessorDataCount: number = count * componentCount;\r\n\r\n        let res;\r\n\r\n        let bufferView: glTF.glTFBufferView = this._data.bufferViews[accessor.bufferView];\r\n        if (bufferView) {\r\n            res = this.getBufferFormBufferView(bufferView, accessor.byteOffset, accessor.type, accessor.componentType, accessorDataCount);\r\n        }\r\n        else {\r\n            const constructor = this._getTypedArrayConstructor(accessor.componentType);\r\n            res = new constructor(accessorDataCount).fill(0);\r\n        }\r\n\r\n        if (accessor.sparse) {\r\n            let sparseCount = accessor.sparse.count;\r\n            let sparseIndices = accessor.sparse.indices;\r\n            let sparseIndicesBufferView = this._data.bufferViews[sparseIndices.bufferView];\r\n            let sparseIndicesData = this.getBufferFormBufferView(sparseIndicesBufferView, sparseIndices.byteOffset, accessor.type, sparseIndices.componentType, sparseCount);\r\n\r\n            let sparseValues = accessor.sparse.values;\r\n            let sparseValuesBufferView = this._data.bufferViews[sparseValues.bufferView];\r\n            let sparseValuesData = this.getBufferFormBufferView(sparseValuesBufferView, sparseValues.byteOffset, accessor.type, accessor.componentType, sparseCount * componentCount);\r\n\r\n            for (let index = 0; index < sparseCount; index++) {\r\n                let i = sparseIndicesData[index];\r\n                for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {\r\n                    res[i * componentCount + componentIndex] = sparseValuesData[index * componentCount + componentIndex];\r\n                }\r\n            }\r\n        }\r\n\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * 判断 Texture 是否需要 mipmap\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTextureMipmap(glTFSampler: glTF.glTFSampler): boolean {\r\n        if (glTFSampler)\r\n            return glTFSampler.minFilter != glTF.glTFTextureMinFilter.LINEAR &&\r\n                glTFSampler.minFilter != glTF.glTFTextureMinFilter.NEAREST;\r\n        else\r\n            return true;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture format\r\n     * @param glTFImage \r\n     */\r\n    private getTextureFormat(glTFImage: glTF.glTFImage): number {\r\n        if (glTFImage.mimeType === glTF.glTFImageMimeType.JPEG) {\r\n            return 0;   // R8G8B8\r\n        }\r\n        else {\r\n            return 1;   // R8G8B8A8\r\n        }\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture filter mode\r\n     * @param glTFSampler \r\n     */\r\n    private getTextureFilterMode(glTFSampler: glTF.glTFSampler): number {\r\n\r\n        if (!glTFSampler) {\r\n            return 1;\r\n        }\r\n\r\n        if (glTFSampler.magFilter === glTF.glTFTextureMagFilter.NEAREST) {\r\n            return 0;   // FilterMode.Point\r\n        }\r\n        else if (this.getTextureMipmap(glTFSampler)) {\r\n            if (glTFSampler.minFilter === glTF.glTFTextureMinFilter.LINEAR_MIPMAP_LINEAR)\r\n                return 2;   // FilterMode.Trilinear\r\n\r\n            return 1;   // FilterMode.Bilinear\r\n        }\r\n\r\n        return 1;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture warp mode\r\n     * @param mode \r\n     */\r\n    private getTextureWrapMode(mode: glTF.glTFTextureWrapMode): number {\r\n        if (mode === glTF.glTFTextureWrapMode.CLAMP_TO_EDGE) {\r\n            return 1;   // WrapMode.Clamp\r\n        }\r\n        return 0;   // WrapMode.Repeat\r\n    }\r\n\r\n    /**\r\n    * 获取 Texture 初始化参数\r\n    * @param glTFImage \r\n    * @param glTFSampler \r\n    */\r\n    private getTextureConstructParams(glTFImage: glTF.glTFImage, glTFSampler: glTF.glTFSampler, sRGB: boolean): ConstructorParameters<typeof Texture2D> {\r\n        let constructParams: ConstructorParameters<typeof Texture2D> = [\r\n            0, // width\r\n            0, // height\r\n            this.getTextureFormat(glTFImage), // format\r\n            this.getTextureMipmap(glTFSampler),  // mipmap\r\n            false, //can read\r\n            sRGB // sRGB\r\n\r\n        ];\r\n        return constructParams;\r\n    }\r\n\r\n    /**\r\n     * 获取 Texture 属性参数\r\n     * @param glTFImage \r\n     * @param glTFSampler \r\n     */\r\n    private getTexturePropertyParams(glTFSampler: glTF.glTFSampler): TexturePropertyParams {\r\n        if (!glTFSampler) {\r\n            return null;\r\n        }\r\n\r\n        let propertyParams: TexturePropertyParams = {\r\n            filterMode: this.getTextureFilterMode(glTFSampler),\r\n            wrapModeU: this.getTextureWrapMode(glTFSampler.wrapS),\r\n            wrapModeV: this.getTextureWrapMode(glTFSampler.wrapT),\r\n            anisoLevel: 1,\r\n            hdrEncodeFormat: HDREncodeFormat.NONE\r\n        };\r\n        return propertyParams;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFTextureInfo 获取 Texture2D\r\n     * @param glTFTextureInfo \r\n     */\r\n    getTextureWithInfo(glTFTextureInfo: glTF.glTFTextureInfo): Texture2D {\r\n\r\n        // uv 非 0 \r\n        if (glTFTextureInfo.texCoord) {\r\n            // todo 非0 uv \r\n            console.warn(\"glTF Loader: non 0 uv channel unsupported.\");\r\n        }\r\n\r\n        // let glTFImage: glTF.glTFTexture = this._glTF.textures[glTFTextureInfo.index];\r\n        return this._textures[glTFTextureInfo.index];\r\n    }\r\n\r\n    /**\r\n     * \r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyMaterialRenderState(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n        // material render state\r\n        let renderMode: glTF.glTFMaterialAlphaMode = glTFMaterial.alphaMode || glTF.glTFMaterialAlphaMode.OPAQUE;\r\n        switch (renderMode) {\r\n            case glTF.glTFMaterialAlphaMode.OPAQUE: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_OPAQUE;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.BLEND: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_TRANSPARENT;\r\n                break;\r\n            }\r\n            case glTF.glTFMaterialAlphaMode.MASK: {\r\n                material.materialRenderMode = MaterialRenderMode.RENDERMODE_CUTOUT;\r\n                break;\r\n            }\r\n            default: {\r\n                // todo\r\n            }\r\n        }\r\n\r\n        material.alphaTestValue = glTFMaterial.alphaCutoff ?? 0.5;\r\n\r\n        if (glTFMaterial.doubleSided) {\r\n            material.cull = RenderState.CULL_NONE;\r\n        }\r\n\r\n    }\r\n\r\n    /**\r\n     * @param glTFMaterial \r\n     * @param material \r\n     */\r\n    applyDefaultMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material) {\r\n\r\n        {\r\n            let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n            if (pbrMetallicRoughness) {\r\n                if (pbrMetallicRoughness.baseColorFactor) {\r\n                    let baseColorFactor = material.getVector4(\"u_BaseColorFactor\");\r\n                    baseColorFactor.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                    material.setVector4(\"u_BaseColorFactor\", baseColorFactor);\r\n                }\r\n                if (pbrMetallicRoughness.baseColorTexture) {\r\n                    let tex = this.getTextureWithInfo(pbrMetallicRoughness.baseColorTexture);\r\n                    material.setTexture(\"u_BaseColorTexture\", tex);\r\n                    material.setDefine(glTFShader.Define_BaseMap, true);\r\n                }\r\n\r\n                let metallicFactor = pbrMetallicRoughness.metallicFactor ?? 1.0;\r\n                material.setFloat(\"u_MetallicFactor\", metallicFactor);\r\n\r\n                let roughnessFactor = pbrMetallicRoughness.roughnessFactor ?? 1.0;\r\n                material.setFloat(\"u_RoughnessFactor\", roughnessFactor);\r\n\r\n                if (pbrMetallicRoughness.metallicRoughnessTexture) {\r\n                    let tex = this.getTextureWithInfo(pbrMetallicRoughness.metallicRoughnessTexture);\r\n                    material.setTexture(\"u_MetallicRoughnessTexture\", tex);\r\n                    material.setDefine(glTFShader.Define_MetallicRoughnessMap, true);\r\n                }\r\n            }\r\n\r\n            if (glTFMaterial.normalTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.normalTexture);\r\n                material.setTexture(\"u_NormalTexture\", tex);\r\n                material.setDefine(glTFShader.Define_NormalMap, true);\r\n                let normalScale = glTFMaterial.normalTexture.scale ?? 1.0;\r\n                material.setFloat(\"u_NormalScale\", normalScale);\r\n            }\r\n\r\n            if (glTFMaterial.occlusionTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.occlusionTexture);\r\n                material.setTexture(\"u_OcclusionTexture\", tex);\r\n                material.setDefine(glTFShader.Define_OcclusionMap, true);\r\n                let strength = glTFMaterial.occlusionTexture.strength ?? 1.0;\r\n                material.setFloat(\"u_OcclusionStrength\", strength);\r\n            }\r\n\r\n            if (glTFMaterial.emissiveFactor) {\r\n                let emissionFactor = material.getVector3(\"u_EmissionFactor\");\r\n                emissionFactor.fromArray(glTFMaterial.emissiveFactor);\r\n                material.setVector3(\"u_EmissionFactor\", emissionFactor);\r\n                material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n            }\r\n\r\n            if (glTFMaterial.emissiveTexture) {\r\n                let tex = this.getTextureWithInfo(glTFMaterial.emissiveTexture);\r\n                material.setTexture(\"u_EmissionTexture\", tex);\r\n                material.setDefine(PBRShaderLib.DEFINE_EMISSION, true);\r\n                material.setDefine(glTFShader.Define_EmissionMap, true);\r\n            }\r\n\r\n            this.applyMaterialRenderState(glTFMaterial, material);\r\n        }\r\n        return;\r\n    }\r\n\r\n    /**\r\n     * 根据 glTFMaterial 节点数据创建 default Material\r\n     * @param glTFMaterial \r\n     */\r\n    createDefaultMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let material = new Material();\r\n        material.setShaderName(glTFShader.ShaderName);\r\n\r\n        // apply glTF Material property\r\n        material.name = glTFMaterial.name ? glTFMaterial.name : \"\";\r\n\r\n        this.applyDefaultMaterialProperties(glTFMaterial, material);\r\n\r\n        return material;\r\n    }\r\n\r\n    protected createMaterial(glTFMaterial: glTF.glTFMaterial) {\r\n        let mat: Material = null;\r\n        let propertiesExts = [];\r\n        for (const key in glTFMaterial.extensions) {\r\n            let extension = this._extensions.find(value => value.name == key);\r\n            if (extension) {\r\n                if (extension.createMaterial) {\r\n                    mat = extension.createMaterial(glTFMaterial);\r\n                }\r\n                if (extension.additionMaterialProperties) {\r\n                    propertiesExts.push(extension);\r\n                }\r\n            }\r\n        }\r\n\r\n        if (!mat) {\r\n            mat = this.createDefaultMaterial(glTFMaterial);\r\n        }\r\n        propertiesExts.forEach(extension => {\r\n            extension.additionMaterialProperties(glTFMaterial, mat);\r\n        });\r\n\r\n        return mat;\r\n    }\r\n\r\n    /**\r\n     * 获取 gltf mesh 中 material \r\n     * @param glTFMesh \r\n     */\r\n    private pickMeshMaterials(glTFMesh: glTF.glTFMesh): Material[] {\r\n        let materials: Material[] = [];\r\n\r\n        glTFMesh.primitives.forEach(primitive => {\r\n            if (primitive.material != undefined) {\r\n                let material: Material = this._materials[primitive.material];\r\n                materials.push(material);\r\n            }\r\n            else {\r\n                let material: Material = new PBRStandardMaterial();\r\n                materials.push(material);\r\n                this._materials.push(material);\r\n                primitive.material = this._materials.indexOf(material);\r\n            }\r\n        });\r\n\r\n        return materials;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private loadScenes(glTFScenes?: glTF.glTFScene[]): void {\r\n        if (!glTFScenes)\r\n            return;\r\n\r\n        glTFScenes.forEach((glTFScene, index) => {\r\n            this._scenes[index] = this._loadScene(glTFScene);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载场景节点\r\n     * @param glTFScene \r\n     */\r\n    private _loadScene(glTFScene: glTF.glTFScene): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this._createSceneNode(glTFScene);\r\n    }\r\n\r\n    /**\r\n     * 创建 glTFScene 节点\r\n     * @param glTFScene \r\n     */\r\n    private _createSceneNode(glTFScene: glTF.glTFScene): Sprite3D {\r\n        let glTFSceneNode: Sprite3D = new Sprite3D(glTFScene.name || \"Scene\");\r\n        glTFScene.nodes.forEach(nodeIndex => {\r\n            let sprite: Sprite3D = this._nodes[nodeIndex];\r\n            glTFSceneNode.addChild(sprite);\r\n        });\r\n\r\n        return glTFSceneNode;\r\n    }\r\n\r\n    /**\r\n     * 应用 Transform 信息\r\n     * @param glTFNode \r\n     * @param sprite \r\n     */\r\n    private applyTransform(glTFNode: glTF.glTFNode, sprite: Sprite3D): void {\r\n        if (glTFNode.matrix) {\r\n            let localMatrix: Matrix4x4 = sprite.transform.localMatrix;\r\n            localMatrix.elements.set(glTFNode.matrix);\r\n            sprite.transform.localMatrix = localMatrix;\r\n        }\r\n        else {\r\n            let localPosition: Vector3 = sprite.transform.localPosition;\r\n            let localRotation: Quaternion = sprite.transform.localRotation;\r\n            let localScale: Vector3 = sprite.transform.localScale;\r\n            glTFNode.translation && localPosition.fromArray(glTFNode.translation);\r\n            glTFNode.rotation && localRotation.fromArray(glTFNode.rotation);\r\n            glTFNode.scale && localScale.fromArray(glTFNode.scale);\r\n            sprite.transform.localPosition = localPosition;\r\n            sprite.transform.localRotation = localRotation;\r\n            sprite.transform.localScale = localScale;\r\n        }\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 构建 当前 glTF 对象 节点树\r\n     * @param glTFNodes \r\n     */\r\n    private buildHierarchy(glTFNodes: glTF.glTFNode[]): void {\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (glTFNode.children) {\r\n                glTFNode.children.forEach((childIndex: number) => {\r\n                    let child: Sprite3D = this._nodes[childIndex];\r\n                    sprite.addChild(child);\r\n                });\r\n            }\r\n        });\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            let sprite: Sprite3D = this._nodes[index];\r\n            if (sprite instanceof SkinnedMeshSprite3D) {\r\n                this.fixSkinnedSprite(glTFNode, sprite);\r\n            }\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNodes \r\n     */\r\n    private loadNodes(glTFNodes?: glTF.glTFNode[]): void {\r\n        if (!glTFNodes)\r\n            return;\r\n\r\n        glTFNodes.forEach((glTFNode: glTF.glTFNode, index: number) => {\r\n            this._nodes[index] = this.loadNode(glTFNode);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 glTF 节点\r\n     * @param glTFNode \r\n     */\r\n    private loadNode(glTFNode: glTF.glTFNode): Sprite3D {\r\n        // todo extension and extra\r\n\r\n        return this.createSprite3D(glTFNode);\r\n    }\r\n\r\n    /**\r\n     * 创建 节点对象\r\n     * @param glTFNode \r\n     */\r\n    private createSprite3D(glTFNode: glTF.glTFNode): Sprite3D {\r\n        let sprite: Sprite3D;\r\n        if (glTFNode.skin != null) {\r\n            sprite = this.createSkinnedMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else if (glTFNode.mesh != null) {\r\n            sprite = this.createMeshSprite3D(glTFNode);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n        else {\r\n            sprite = new Sprite3D(glTFNode.name);\r\n            this.applyTransform(glTFNode, sprite);\r\n        }\r\n\r\n        let storeId = this.generateId(\"node\");\r\n        sprite.name = glTFNode.name || `node_${storeId}`;\r\n        (<any>sprite._extra).storeId = \"#\" + storeId;\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createMeshSprite3D(glTFNode: glTF.glTFNode): MeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh = this._meshes[glTFNode.mesh];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: MeshSprite3D = new MeshSprite3D(mesh, glTFNode.name);\r\n        sprite.meshRenderer.sharedMaterials = materials;\r\n        sprite.meshRenderer.receiveShadow = true;\r\n        sprite.meshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.meshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * 创建 MeshSprite3D 对象\r\n     * @param glTFNode \r\n     */\r\n    private createSkinnedMeshSprite3D(glTFNode: glTF.glTFNode): SkinnedMeshSprite3D {\r\n        let glTFMesh: glTF.glTFMesh = this._data.meshes[glTFNode.mesh];\r\n        let mesh: Mesh = this._meshes[glTFNode.mesh + \"_\" + glTFNode.skin];\r\n        let materials: Material[] = this.pickMeshMaterials(glTFMesh);\r\n        let sprite: SkinnedMeshSprite3D = new SkinnedMeshSprite3D(mesh, glTFNode.name);\r\n        sprite.skinnedMeshRenderer.sharedMaterials = materials;\r\n        sprite.skinnedMeshRenderer.receiveShadow = true;\r\n        sprite.skinnedMeshRenderer.castShadow = true;\r\n\r\n        if (glTFMesh.weights) {\r\n            let render = sprite.skinnedMeshRenderer;\r\n            glTFMesh.weights.forEach((weight, index) => {\r\n                let target = mesh.morphTargetData.getMorphChannelbyIndex(index);\r\n                render.setMorphChannelWeight(target.name, weight);\r\n            });\r\n        }\r\n\r\n        return sprite;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 attribute buffer 数据\r\n     * @param attributeAccessorIndex \r\n     * @param layaDeclarStr \r\n     * @param attributes \r\n     * @param vertexDeclarArr \r\n     * @param func \r\n     */\r\n    private getArrributeBuffer(attributeAccessorIndex: number, layaDeclarStr: string, attributeMap: Map<string, Float32Array>, vertexDeclarArr: string[]): Float32Array {\r\n        let attributeBuffer: Float32Array = <Float32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (!attributeBuffer)\r\n            return null;\r\n        vertexDeclarArr.push(layaDeclarStr);\r\n        let res: Float32Array = attributeBuffer;\r\n        attributeMap.set(layaDeclarStr, res);\r\n        return res;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 glTFMeshPrimitive index buffer\r\n     * @param attributeAccessorIndex \r\n     * @param vertexCount \r\n     */\r\n    private getIndexBuffer(attributeAccessorIndex: number, vertexCount: number): Uint32Array {\r\n        let indexBuffer: Uint32Array = <Uint32Array>this.getBufferwithAccessorIndex(attributeAccessorIndex);\r\n        if (indexBuffer) {\r\n            return new Uint32Array(indexBuffer).reverse();\r\n            // return indexBuffer;\r\n        }\r\n        else {\r\n            let indices: Uint32Array = new Uint32Array(vertexCount);\r\n            for (let i = 0; i < vertexCount; i++) {\r\n                indices[i] = vertexCount - 1 - i;\r\n            }\r\n            return indices;\r\n        }\r\n    }\r\n\r\n    private calculateFlatNormal(positions: Float32Array, indexArray: Uint32Array): Float32Array {\r\n        let normal = new Float32Array(positions.length);\r\n\r\n        for (let index = 0; index < indexArray.length; index += 3) {\r\n            // todo\r\n            let i0 = indexArray[index];\r\n            let i1 = indexArray[index + 1];\r\n            let i2 = indexArray[index + 2];\r\n\r\n            let p0x = positions[i0 * 3];\r\n            let p0y = positions[i0 * 3 + 1];\r\n            let p0z = positions[i0 * 3 + 2];\r\n\r\n            let p1x = positions[i1 * 3];\r\n            let p1y = positions[i1 * 3 + 1];\r\n            let p1z = positions[i1 * 3 + 2];\r\n\r\n            let p2x = positions[i2 * 3];\r\n            let p2y = positions[i2 * 3 + 1];\r\n            let p2z = positions[i2 * 3 + 2];\r\n\r\n            let x1 = p1x - p0x;\r\n            let y1 = p1y - p0y;\r\n            let z1 = p1z - p0z;\r\n\r\n            let x2 = p2x - p0x;\r\n            let y2 = p2y - p0y;\r\n            let z2 = p2z - p0z;\r\n\r\n            let yz = y1 * z2 - z1 * y2;\r\n            let xz = z1 * x2 - x1 * z2;\r\n            let xy = x1 * y2 - y1 * x2;\r\n\r\n            let invPyth = -1.0 / (Math.sqrt((yz * yz) + (xz * xz) + (xy * xy)));\r\n            let nx = yz * invPyth;\r\n            let ny = xz * invPyth;\r\n            let nz = xy * invPyth;\r\n\r\n            normal[i0 * 3] = nx;\r\n            normal[i1 * 3] = nx;\r\n            normal[i2 * 3] = nx;\r\n\r\n            normal[i0 * 3 + 1] = ny;\r\n            normal[i1 * 3 + 1] = ny;\r\n            normal[i2 * 3 + 1] = ny;\r\n\r\n            normal[i0 * 3 + 2] = nz;\r\n            normal[i1 * 3 + 2] = nz;\r\n            normal[i2 * 3 + 2] = nz;\r\n        }\r\n\r\n        return normal;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 解析 subData 记录数据\r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private parseMeshwithSubMeshData(subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexCount: number = 0;\r\n        let indexCount: number = 0;\r\n        let vertexDecler: string = undefined;\r\n        subDatas.forEach(subData => {\r\n            vertexCount += subData.vertexCount;\r\n            indexCount += subData.indices.length;\r\n\r\n            vertexDecler = vertexDecler || subData.vertexDecler;\r\n        });\r\n\r\n        let vertexDeclaration: VertexDeclaration = VertexMesh.getVertexDeclaration(vertexDecler, false);\r\n        let vertexByteStride: number = vertexDeclaration.vertexStride;\r\n        let vertexFloatStride: number = vertexByteStride / 4;\r\n\r\n        let vertexArray: Float32Array = new Float32Array(vertexFloatStride * vertexCount);\r\n        let indexArray: Uint16Array | Uint32Array;\r\n        let ibFormat: IndexFormat = IndexFormat.UInt32;\r\n        if (vertexCount < 65536) {\r\n            indexArray = new Uint16Array(indexCount);\r\n            ibFormat = IndexFormat.UInt16;\r\n        }\r\n        else {\r\n            indexArray = new Uint32Array(indexCount);\r\n        }\r\n\r\n        this.fillMeshBuffers(subDatas, vertexArray, indexArray, vertexFloatStride);\r\n        this.generateMesh(vertexArray, indexArray, vertexDeclaration, ibFormat, subDatas, layaMesh);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 填充 mesh buffer 数据\r\n     * @param subDatas \r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexFloatStride \r\n     */\r\n    private fillMeshBuffers(subDatas: PrimitiveSubMesh[], vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexFloatStride: number) {\r\n        let ibPosOffset: number = 0;\r\n        let ibVertexOffset: number = 0;\r\n        let vbPosOffset: number = 0;\r\n        subDatas.forEach((subData) => {\r\n\r\n            let iAOffset: number = ibPosOffset;\r\n\r\n            let vertexCount: number = subData.vertexCount;\r\n\r\n            let subIb: Uint32Array = subData.indices;\r\n            for (let index = 0; index < subIb.length; index++) {\r\n                indexArray[iAOffset + index] = subIb[index] + ibVertexOffset;\r\n            }\r\n            ibPosOffset += subIb.length;\r\n            ibVertexOffset += vertexCount;\r\n\r\n            const fillAttributeBuffer = (value: Float32Array, attriOffset: number, attriFloatCount: number = 0) => {\r\n                let startOffset: number = vbPosOffset + attriOffset;\r\n                for (let index = 0; index < vertexCount; index++) {\r\n                    for (let ac = 0; ac < attriFloatCount; ac++) {\r\n                        vertexArray[startOffset + index * vertexFloatStride + ac] = value[index * attriFloatCount + ac];\r\n                    }\r\n                }\r\n            };\r\n\r\n            let attriOffset: number = 0;\r\n            let attributeMap: Map<string, Float32Array> = subData.attributeMap;\r\n            let position: Float32Array = attributeMap.get(\"POSITION\");\r\n            (position) && (fillAttributeBuffer(position, attriOffset, 3), attriOffset += 3);\r\n            let normal: Float32Array = attributeMap.get(\"NORMAL\");\r\n            (normal) && (fillAttributeBuffer(normal, attriOffset, 3), attriOffset += 3);\r\n            let color: Float32Array = attributeMap.get(\"COLOR\");\r\n            (color) && (fillAttributeBuffer(color, attriOffset, 4), attriOffset += 4);\r\n            let uv: Float32Array = attributeMap.get(\"UV\");\r\n            (uv) && (fillAttributeBuffer(uv, attriOffset, 2), attriOffset += 2);\r\n            let uv1: Float32Array = attributeMap.get(\"UV1\");\r\n            (uv1) && (fillAttributeBuffer(uv1, attriOffset, 2), attriOffset += 2);\r\n            let blendWeight: Float32Array = attributeMap.get(\"BLENDWEIGHT\");\r\n            (blendWeight) && (fillAttributeBuffer(blendWeight, attriOffset, 4), attriOffset += 4);\r\n            let blendIndices: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n            if (blendIndices) {\r\n                let blendIndicesUint8: Uint8Array = new Uint8Array(blendIndices);\r\n                let blendIndicesFloat32: Float32Array = new Float32Array(blendIndicesUint8.buffer);\r\n                fillAttributeBuffer(blendIndicesFloat32, attriOffset, 1), attriOffset += 1;\r\n            }\r\n            let tangent: Float32Array = attributeMap.get(\"TANGENT\");\r\n            (tangent) && (fillAttributeBuffer(tangent, attriOffset, 4), attriOffset += 4);\r\n\r\n            vbPosOffset += vertexCount * vertexFloatStride;\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 根据 单次提交最大骨骼数量 划分 submesh 提交队列\r\n     * @param attributeMap \r\n     * @param indexArray \r\n     * @param boneIndicesList \r\n     * @param subIndexStartArray \r\n     * @param subIndexCountArray \r\n     */\r\n    private splitSubMeshByBonesCount(attributeMap: Map<string, Float32Array>, morphtargets: SubMorphData, indexArray: Uint32Array, boneIndicesList: Array<Uint16Array>, subIndexStartArray: number[], subIndexCountArray: number[]): void {\r\n        let start: number = 0;\r\n        let subIndexSet: Set<number> = new Set();\r\n        let boneIndexArray: Float32Array = attributeMap.get(\"BLENDINDICES\");\r\n\r\n        let vertexCount: number = boneIndexArray.length / 4;\r\n\r\n        let resArray: Float32Array = new Float32Array(boneIndexArray.length);\r\n\r\n        let flagArray: Array<boolean> = new Array(vertexCount).fill(false);\r\n\r\n        // 遍历 ib\r\n        for (let i: number = 0, n: number = indexArray.length; i < n; i += 3) {\r\n            // 每三个顶点 一个三角形 一起判断\r\n            // 三个顶点 ，12 个 bone index\r\n            let triangleSet: Set<number> = new Set();\r\n            for (let j: number = i; j < i + 3; j++) {\r\n                let ibIndex: number = indexArray[j];\r\n                let boneIndexOffset: number = ibIndex * 4;\r\n                for (let k: number = 0; k < 4; k++) {\r\n                    triangleSet.add(boneIndexArray[boneIndexOffset + k]);\r\n                }\r\n            }\r\n            // 判断当前\r\n            let tempSet: Set<number> = new Set([...subIndexSet, ...triangleSet]);\r\n            if (tempSet.size > maxSubBoneCount) {\r\n                // 当前批次不能加 添加 下一三角形\r\n                // 保存当前数据\r\n                let count: number = i - start;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n                // 更新 起始位置\r\n                start = i;\r\n                // 新建数据集， 添加未能添加到上一个节点的数据\r\n                subIndexSet = new Set(triangleSet);\r\n            }\r\n            else {\r\n                // 添加数据 到当前数据集\r\n                subIndexSet = tempSet;\r\n            }\r\n            // 结尾 添加剩余数据\r\n            if (i == n - 3) {\r\n                let count: number = i - start + 3;\r\n                subIndexStartArray.push(start);\r\n                subIndexCountArray.push(count);\r\n                start = i;\r\n                let curBoneList: number[] = Array.from(subIndexSet);\r\n                boneIndicesList.push(new Uint16Array(curBoneList));\r\n            }\r\n        }\r\n\r\n        //根据分离出的范围 更改 biarray\r\n        let drawCount: number = boneIndicesList.length;\r\n        let newAttributeMap: Map<string, Array<number>> = new Map();\r\n        attributeMap.forEach((value, key) => {\r\n            let array: Array<number> = new Array();\r\n            newAttributeMap.set(key, array);\r\n        });\r\n\r\n        let newTargetMap: { [name: string]: Map<string, Array<number>> } = {};\r\n        for (const key in morphtargets.targets) {\r\n            let newMap = newTargetMap[key] = new Map();\r\n\r\n            let target = morphtargets.targets[key];\r\n            target.forEach((value, attri) => {\r\n                newMap.set(attri, new Array<number>());\r\n            });\r\n        }\r\n\r\n        let curMaxIndex: number = vertexCount - 1;\r\n        for (let d: number = 0; d < drawCount; d++) {\r\n            let k: number = subIndexStartArray[d];\r\n            let l: number = subIndexCountArray[d];\r\n            let bl: Uint16Array = boneIndicesList[d];\r\n\r\n            let batchFlag: Array<boolean> = new Array(vertexCount).fill(false);\r\n            let batchMap: Map<number, number> = new Map();\r\n            for (let area: number = 0; area < l; area++) {\r\n                let ci: number = indexArray[area + k];\r\n                let biStart: number = 4 * ci;\r\n                for (let cbi: number = biStart; cbi < biStart + 4; cbi++) {\r\n                    let oldBoneIndex: number = boneIndexArray[cbi];\r\n                    let newBoneIndex: number = bl.indexOf(oldBoneIndex);\r\n                    newBoneIndex = newBoneIndex == -1 ? 0 : newBoneIndex;\r\n                    // 其他batch 出现， 此batch 未出现 新增点数据\r\n                    if (flagArray[ci] && !batchFlag[ci]) {\r\n                        newAttributeMap.get(\"BLENDINDICES\").push(newBoneIndex);\r\n                    }\r\n                    // 其他batch 出现， 此batch 出现, 修改过 跳过\r\n                    else if (flagArray[ci] && batchFlag[ci]) {\r\n\r\n                    }\r\n                    else {\r\n                        resArray[cbi] = newBoneIndex;\r\n                    }\r\n                }\r\n                // 其他batch 未出现， 此batch 未出现 不处理\r\n                if (!flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    batchMap.set(ci, ci);\r\n                }\r\n                // 其他btach 未出现， 此batch 已经出现 index 改为上次更新index\r\n                else if (!flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n                //其他batch 出现， 此batch 未出现 新增点数据  更新index\r\n                else if (flagArray[ci] && !batchFlag[ci]) {\r\n                    batchFlag[ci] = true;\r\n                    curMaxIndex++;\r\n                    batchMap.set(ci, curMaxIndex);\r\n                    indexArray[area + k] = curMaxIndex;\r\n                    newAttributeMap.forEach((value: number[], key: string) => {\r\n                        let attOffset: number = this.getAttributeNum(key);\r\n                        let oldArray: Float32Array = attributeMap.get(key);\r\n                        if (key !== \"BLENDINDICES\") {\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n                        }\r\n                    });\r\n\r\n                    for (const key in newTargetMap) {\r\n                        let newMap = newTargetMap[key];\r\n                        let oldMap = morphtargets.targets[key];\r\n                        newMap.forEach((value, attri) => {\r\n                            let attOffset = this.getAttributeNum(attri);\r\n                            let oldArray = oldMap.get(attri);\r\n\r\n                            for (let index = 0; index < attOffset; index++) {\r\n                                value.push(oldArray[index + ci * attOffset]);\r\n                            }\r\n\r\n                        });\r\n                    }\r\n\r\n\r\n                }\r\n                //其他batch 出现， 此batch 出现\r\n                else if (flagArray[ci] && batchFlag[ci]) {\r\n                    indexArray[area + k] = batchMap.get(ci);\r\n                }\r\n            }\r\n            // 将此batch 出现的index更新到flagarray\r\n            batchFlag.forEach((value, index) => {\r\n                flagArray[index] = value || flagArray[index];\r\n            });\r\n        }\r\n\r\n        newAttributeMap.forEach((value: number[], key: string) => {\r\n            let oldFloatArray: Float32Array = attributeMap.get(key);\r\n            if (key == \"BLENDINDICES\") {\r\n                oldFloatArray = resArray;\r\n            }\r\n            let newLength: number = oldFloatArray.length + value.length;\r\n            let newFloatArray: Float32Array = new Float32Array(newLength);\r\n            newFloatArray.set(oldFloatArray, 0);\r\n            newFloatArray.set(value, oldFloatArray.length);\r\n            attributeMap.set(key, newFloatArray);\r\n        });\r\n\r\n        for (const key in newTargetMap) {\r\n            let newMap = newTargetMap[key];\r\n            let oldMap = morphtargets.targets[key];\r\n\r\n            newMap.forEach((value, attri) => {\r\n                let oldArray = oldMap.get(attri);\r\n                let newLength = value.length + oldArray.length;\r\n\r\n                let newFloatArray = new Float32Array(newLength);\r\n                newFloatArray.set(oldArray, 0);\r\n                newFloatArray.set(value, oldArray.length);\r\n                oldMap.set(attri, newFloatArray);\r\n            });\r\n        }\r\n\r\n        boneIndexArray = null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 生成 mesh\r\n     * @param vertexArray \r\n     * @param indexArray \r\n     * @param vertexDeclaration \r\n     * @param ibFormat \r\n     * @param subDatas \r\n     * @param layaMesh \r\n     */\r\n    private generateMesh(vertexArray: Float32Array, indexArray: Uint16Array | Uint32Array, vertexDeclaration: VertexDeclaration, ibFormat: IndexFormat, subDatas: PrimitiveSubMesh[], layaMesh: Mesh): void {\r\n        let vertexBuffer: VertexBuffer3D = LayaGL.renderOBJCreate.createVertexBuffer3D(vertexArray.byteLength, BufferUsage.Static, true);\r\n        vertexBuffer.vertexDeclaration = vertexDeclaration;\r\n        vertexBuffer.setData(vertexArray.buffer);\r\n\r\n        let indexBuffer: IndexBuffer3D = LayaGL.renderOBJCreate.createIndexBuffer3D(ibFormat, indexArray.length, BufferUsage.Static, true);\r\n        indexBuffer.setData(indexArray);\r\n\r\n        layaMesh._indexFormat = ibFormat;\r\n        layaMesh._indexBuffer = indexBuffer;\r\n        layaMesh._vertexBuffer = vertexBuffer;\r\n        layaMesh._setBuffer(vertexBuffer, indexBuffer);\r\n        layaMesh._vertexCount = vertexBuffer._byteLength / vertexDeclaration.vertexStride;\r\n\r\n        let reCalculateBounds = false;\r\n        let min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        // subMesh\r\n        let subMeshOffset: number = 0;\r\n        let subMeshCount: number = subDatas.length;\r\n        let subMeshes: SubMesh[] = new Array<SubMesh>(subMeshCount);\r\n        for (let index = 0; index < subMeshCount; index++) {\r\n            let subData: PrimitiveSubMesh = subDatas[index];\r\n\r\n            let subMesh: SubMesh = new SubMesh(layaMesh);\r\n            subMeshes[index] = subMesh;\r\n\r\n            subMesh._vertexBuffer = vertexBuffer;\r\n            subMesh._indexBuffer = indexBuffer;\r\n\r\n            let subIndexStart: number = subMeshOffset;\r\n            subMeshOffset += subData.indices.length;\r\n            let subIndexCount: number = subData.indices.length;\r\n            subMesh._setIndexRange(subIndexStart, subIndexCount, ibFormat);\r\n\r\n            subMesh._boneIndicesList = subData.boneIndicesList;\r\n            subMesh._subIndexBufferStart = subData.subIndexStartArray;\r\n            subMesh._subIndexBufferCount = subData.subIndexCountArray;\r\n\r\n            for (let subIndex = 0; subIndex < subMesh._subIndexBufferStart.length; subIndex++) {\r\n                subMesh._subIndexBufferStart[subIndex] += subIndexStart;\r\n            }\r\n\r\n            if (subData.boundMax && subData.boundMin) {\r\n                min.x = Math.min(subData.boundMin[0], min.x);\r\n                min.y = Math.min(subData.boundMin[1], min.y);\r\n                min.z = Math.min(subData.boundMin[2], min.z);\r\n\r\n                max.x = Math.max(subData.boundMax[0], max.x);\r\n                max.y = Math.max(subData.boundMax[1], max.y);\r\n                max.z = Math.max(subData.boundMax[2], max.z);\r\n            }\r\n            else {\r\n                reCalculateBounds = true;\r\n            }\r\n        }\r\n\r\n        layaMesh._setSubMeshes(subMeshes);\r\n        if (reCalculateBounds) {\r\n            layaMesh.calculateBounds();\r\n        }\r\n        else {\r\n            layaMesh.bounds.setMin(min);\r\n            layaMesh.bounds.setMax(max);\r\n        }\r\n\r\n        //layaMesh._setInstanceBuffer(Mesh.MESH_INSTANCEBUFFER_TYPE_NORMAL);\r\n\r\n        // 资源面板\r\n        // todo mesh.read = flase ? \r\n        let memorySize: number = vertexBuffer._byteLength + indexBuffer._byteLength;\r\n        layaMesh._setCPUMemory(memorySize);\r\n        layaMesh._setGPUMemory(memorySize);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * mesh 应用蒙皮数据\r\n     * @param mesh \r\n     * @param glTFSkin \r\n     */\r\n    private applyglTFSkinData(mesh: Mesh, subDatas: PrimitiveSubMesh[], glTFSkin?: glTF.glTFSkin): void {\r\n        if (!glTFSkin)\r\n            return;\r\n\r\n        let joints: number[] = glTFSkin.joints;\r\n\r\n        let inverseBindMatricesArray: Float32Array = new Float32Array(this.getBufferwithAccessorIndex(glTFSkin.inverseBindMatrices));\r\n\r\n        let boneCount: number = joints.length;\r\n        let boneNames: string[] = mesh._boneNames = [];\r\n        joints.forEach(nodeIndex => {\r\n            let node: glTF.glTFNode = this._data.nodes[nodeIndex];\r\n            boneNames.push(node.name);\r\n        })\r\n\r\n        mesh._inverseBindPoses = [];\r\n        mesh._inverseBindPosesBuffer = inverseBindMatricesArray.buffer;\r\n        for (let index = 0; index < boneCount; index++) {\r\n            let bindPosesArrayOffset: number = 16 * index;\r\n            let matElement: Float32Array = inverseBindMatricesArray.slice(bindPosesArrayOffset, bindPosesArrayOffset + 16);\r\n            mesh._inverseBindPoses[index] = new Matrix4x4(\r\n                matElement[0], matElement[1], matElement[2], matElement[3],\r\n                matElement[4], matElement[5], matElement[6], matElement[7],\r\n                matElement[8], matElement[9], matElement[10], matElement[11],\r\n                matElement[12], matElement[13], matElement[14], matElement[15],\r\n                matElement\r\n            );\r\n        }\r\n\r\n        let subCount: number = subDatas.length;\r\n        let skinnedCache: skinnedMatrixCache[] = mesh._skinnedMatrixCaches;\r\n        skinnedCache.length = mesh._inverseBindPoses.length;\r\n        for (let subIndex: number = 0; subIndex < subCount; subIndex++) {\r\n            let submesh: SubMesh = mesh.getSubMesh(subIndex);\r\n            let drawCount: number = submesh._subIndexBufferStart.length;\r\n            for (let drawIndex: number = 0; drawIndex < drawCount; drawIndex++) {\r\n                let boneIndices: Uint16Array = submesh._boneIndicesList[drawIndex];\r\n                for (let bni: number = 0; bni < boneIndices.length; bni++) {\r\n                    let bn: number = boneIndices[bni];\r\n                    skinnedCache[bn] || (skinnedCache[bn] = new skinnedMatrixCache(subIndex, drawIndex, bni));\r\n                }\r\n            }\r\n        }\r\n\r\n        for (let index = 0; index < skinnedCache.length; index++) {\r\n            if (!skinnedCache[index]) {\r\n                skinnedCache[index] = new skinnedMatrixCache(0, 0, 0);\r\n            }\r\n        }\r\n    }\r\n\r\n    private applyMorphTarget(mesh: Mesh, subDatas: PrimitiveSubMesh[]) {\r\n\r\n        let hasPosition = false;\r\n        let hasNormal = false;\r\n        let hasTangent = false;\r\n\r\n        subDatas.forEach(subData => {\r\n            hasPosition = subData.morphtargets.position || hasPosition;\r\n            hasNormal = subData.morphtargets.normal || hasNormal;\r\n            hasTangent = subData.morphtargets.tangent || hasTangent;\r\n        });\r\n\r\n        if (!(hasPosition || hasTangent || hasTangent)) {\r\n            return;\r\n        }\r\n\r\n        let vertexCount = mesh.vertexCount;\r\n\r\n        let morphData = new MorphTargetData();\r\n        morphData.vertexCount = vertexCount;\r\n\r\n        let decStr = [];\r\n        if (hasPosition)\r\n            decStr.push(\"POSITION\");\r\n        if (hasNormal)\r\n            decStr.push(\"NORMAL\");\r\n        if (hasTangent)\r\n            decStr.push(\"TANGENT\");\r\n\r\n        let morphVertexDec = VertexMesh.getVertexDeclaration(decStr.toLocaleString());\r\n        let targetVertexFloatStride = morphVertexDec.vertexStride / 4;\r\n\r\n        morphData.vertexDec = morphVertexDec;\r\n\r\n        let bounds = morphData.bounds;\r\n        let min = bounds.getMin();\r\n        let max = bounds.getMax();\r\n        min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        let subVertexOffset = 0;\r\n        for (let index = 0; index < subDatas.length; index++) {\r\n            let subData = subDatas[index];\r\n\r\n            min.x = Math.min(min.x, subData.morphtargets.boundMin[0]);\r\n            min.y = Math.min(min.y, subData.morphtargets.boundMin[1]);\r\n            min.z = Math.min(min.z, subData.morphtargets.boundMin[2]);\r\n\r\n            max.x = Math.max(max.x, subData.morphtargets.boundMax[0]);\r\n            max.y = Math.max(max.y, subData.morphtargets.boundMax[1]);\r\n            max.z = Math.max(max.z, subData.morphtargets.boundMax[2]);\r\n\r\n            let targets = subData.morphtargets.targets;\r\n            // glTF do not support in-between blendshape\r\n            for (const targetName in targets) {\r\n\r\n                let channel = morphData.getMorphChannel(targetName);\r\n                if (!channel) {\r\n                    channel = new MorphTargetChannel();\r\n                    channel.name = targetName;\r\n\r\n                    let target = new MorphTarget();\r\n                    target.name = targetName;\r\n                    target.data = new Float32Array(vertexCount * targetVertexFloatStride).fill(0);\r\n\r\n                    channel.addTarget(target);\r\n                    morphData.addMorphChannel(channel);\r\n                }\r\n\r\n                let target = channel.getTargetByIndex(0);\r\n                let morphMap = targets[targetName];\r\n\r\n                for (let vertexIndex = 0; vertexIndex < subData.vertexCount; vertexIndex++) {\r\n                    let morphPosition = morphMap.get(\"POSITION\");\r\n                    if (morphPosition) {\r\n                        let posElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_POSITION0);\r\n                        let offset = posElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphPosition[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphPosition[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphPosition[vertexIndex * 3 + 2];\r\n                    }\r\n\r\n                    let morphNormal = morphMap.get(\"NORMAL\");\r\n                    if (morphNormal) {\r\n                        let normalElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_NORMAL0);\r\n                        let offset = normalElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphNormal[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphNormal[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphNormal[vertexIndex * 3 + 2];\r\n                    }\r\n                    let morphTangent = morphMap.get(\"TANGENT\");\r\n                    if (morphTangent) {\r\n                        let tangentElement = morphVertexDec.getVertexElementByUsage(VertexMesh.MESH_TANGENT0);\r\n                        let offset = tangentElement.offset / 4;\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset] = morphTangent[vertexIndex * 3];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 1] = morphTangent[vertexIndex * 3 + 1];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 2] = morphTangent[vertexIndex * 3 + 2];\r\n                        target.data[(vertexIndex + subVertexOffset) * targetVertexFloatStride + offset + 3] = subData.attributeMap.get(\"TANGENT\")[vertexIndex * 4 + 3];\r\n                    }\r\n                }\r\n            }\r\n\r\n            subVertexOffset += subData.vertexCount;\r\n        }\r\n\r\n        bounds.setMin(min);\r\n        bounds.setMax(max);\r\n\r\n        mesh.morphTargetData = morphData;\r\n        morphData.initData();\r\n    }\r\n\r\n    /**\r\n     * 创建 Mesh\r\n     * @param mesh \r\n     */\r\n    protected createMesh(glTFMesh: glTF.glTFMesh, glTFSkin?: glTF.glTFSkin): Mesh {\r\n        let layaMesh: Mesh = new Mesh();\r\n\r\n        let glTFMeshPrimitives: glTF.glTFMeshPrimitive[] = glTFMesh.primitives;\r\n        let morphWeights: number[] = glTFMesh.weights;\r\n\r\n        let boneCount: number = (glTFSkin) ? glTFSkin.joints.length : 0;\r\n        let subDatas: PrimitiveSubMesh[] = [];\r\n\r\n        glTFMeshPrimitives.forEach((glTFMeshPrimitive: glTF.glTFMeshPrimitive) => {\r\n\r\n            let mode: glTF.glTFMeshPrimitiveMode = glTFMeshPrimitive.mode;\r\n            if (mode == undefined)\r\n                mode = glTF.glTFMeshPrimitiveMode.TRIANGLES;\r\n            if (glTF.glTFMeshPrimitiveMode.TRIANGLES != mode) {\r\n                // todo  只支持 gl.TRIANGLES 模式\r\n                console.warn(\"glTF Loader: only support gl.TRIANGLES.\");\r\n                debugger;\r\n            }\r\n\r\n            let vertexDeclarArr: string[] = [];\r\n            let attributeMap: Map<string, Float32Array> = new Map();\r\n            let attributes: { [name: string]: number } = glTFMeshPrimitive.attributes;\r\n\r\n            let position: Float32Array = this.getArrributeBuffer(attributes.POSITION, \"POSITION\", attributeMap, vertexDeclarArr);\r\n            let vertexCount: number = position.length / 3;\r\n            let indexArray: Uint32Array = this.getIndexBuffer(glTFMeshPrimitive.indices, vertexCount);\r\n            let positionAccessor = this._data.accessors[attributes.POSITION];\r\n\r\n            let normal: Float32Array = this.getArrributeBuffer(attributes.NORMAL, \"NORMAL\", attributeMap, vertexDeclarArr);\r\n            /**\r\n             * When normals are not specified, client implementations MUST calculate flat normals and the provided tangents (if present) MUST be ignored.\r\n             */\r\n            if (!normal) {\r\n                normal = this.calculateFlatNormal(position, indexArray);\r\n                vertexDeclarArr.push(\"NORMAL\");\r\n                attributeMap.set(\"NORMAL\", normal);\r\n            }\r\n\r\n            let color: Float32Array = this.getArrributeBuffer(attributes.COLOR_0, \"COLOR\", attributeMap, vertexDeclarArr);\r\n            let uv: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_0, \"UV\", attributeMap, vertexDeclarArr);\r\n            let uv1: Float32Array = this.getArrributeBuffer(attributes.TEXCOORD_1, \"UV1\", attributeMap, vertexDeclarArr);\r\n            let blendWeight: Float32Array = this.getArrributeBuffer(attributes.WEIGHTS_0, \"BLENDWEIGHT\", attributeMap, vertexDeclarArr);\r\n            let blendIndices: Float32Array = this.getArrributeBuffer(attributes.JOINTS_0, \"BLENDINDICES\", attributeMap, vertexDeclarArr);\r\n\r\n            let tangent: Float32Array;\r\n            tangent = this.getArrributeBuffer(attributes.TANGENT, \"TANGENT\", attributeMap, vertexDeclarArr);\r\n            // :(\r\n            if (tangent) {\r\n                for (let tangentIndex = 0; tangentIndex < tangent.length; tangentIndex += 4) {\r\n                    tangent[tangentIndex + 3] *= -1;\r\n                }\r\n            }\r\n\r\n            // todo  vertex color\r\n            // if (color) {\r\n            //     let material = glTFUtils._glTFMaterials[glTFMeshPrimitive.material];\r\n            //     material.enableVertexColor = true;\r\n            // }\r\n\r\n            let targets: { [name: string]: number }[] = glTFMeshPrimitive.targets;\r\n            let morphtargets: SubMorphData = { weights: morphWeights, position: false, normal: false, tangent: false, targets: {}, boundMin: [Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE], boundMax: [-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE] };\r\n            if (targets) {\r\n\r\n                let morphtargetMap: { [name: string]: Map<string, Float32Array> };\r\n                let targetNames = glTFMesh.extras?.targetNames || [];\r\n                morphtargetMap = morphtargets.targets;\r\n\r\n                targets.forEach((target, index) => {\r\n                    let targetName = targetNames[index] || `target_${index}`;\r\n                    let morph = new Map<string, Float32Array>();\r\n                    morphtargetMap[targetName] = morph;\r\n\r\n                    let morphPosition = <Float32Array>this.getBufferwithAccessorIndex(target.POSITION);\r\n                    let morphNormal = <Float32Array>this.getBufferwithAccessorIndex(target.NORMAL);\r\n                    let morphTangent = <Float32Array>this.getBufferwithAccessorIndex(target.TANGENT);\r\n\r\n                    if (morphPosition) {\r\n                        morph.set(\"POSITION\", morphPosition);\r\n                        morphtargets.position = true;\r\n\r\n                        if (position) {\r\n                            let vertexCount: number = position.length / 3;\r\n\r\n                            for (let i = 0; i < vertexCount; i++) {\r\n                                let offset = i * 3;\r\n\r\n                                let morphX = position[offset] + morphPosition[offset];\r\n                                let morphY = position[offset + 1] + morphPosition[offset + 1];\r\n                                let morphZ = position[offset + 2] + morphPosition[offset + 2];\r\n\r\n                                morphtargets.boundMin[0] = Math.min(morphX, morphtargets.boundMin[0]);\r\n                                morphtargets.boundMin[1] = Math.min(morphY, morphtargets.boundMin[1]);\r\n                                morphtargets.boundMin[2] = Math.min(morphZ, morphtargets.boundMin[2]);\r\n\r\n                                morphtargets.boundMax[0] = Math.max(morphX, morphtargets.boundMax[0]);\r\n                                morphtargets.boundMax[1] = Math.max(morphY, morphtargets.boundMax[1]);\r\n                                morphtargets.boundMax[2] = Math.max(morphZ, morphtargets.boundMax[2]);\r\n                            }\r\n                        }\r\n\r\n                    }\r\n                    if (morphNormal) {\r\n                        morph.set(\"NORMAL\", morphNormal);\r\n                        morphtargets.normal = true;\r\n                    }\r\n                    if (morphTangent) {\r\n                        morph.set(\"TANGENT\", morphTangent);\r\n                        morphtargets.tangent = true;\r\n                    }\r\n                });\r\n            }\r\n\r\n            let boneIndicesList: Array<Uint16Array> = new Array<Uint16Array>();\r\n            let subIndexStartArray: number[] = [];\r\n            let subIndexCountArray: number[] = [];\r\n\r\n            if (glTFSkin) {\r\n                if (boneCount > maxSubBoneCount) {\r\n                    // todo 划分 subMesh\r\n                    this.splitSubMeshByBonesCount(attributeMap, morphtargets, indexArray, boneIndicesList, subIndexStartArray, subIndexCountArray);\r\n                    vertexCount = attributeMap.get(\"POSITION\").length / 3;\r\n                }\r\n                else {\r\n                    subIndexStartArray[0] = 0;\r\n                    subIndexCountArray[0] = indexArray.length;\r\n                    boneIndicesList[0] = new Uint16Array(boneCount);\r\n                    for (let bi = 0; bi < boneCount; bi++) {\r\n                        boneIndicesList[0][bi] = bi;\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                subIndexStartArray[0] = 0;\r\n                subIndexCountArray[0] = indexArray.length;\r\n            }\r\n            let vertexDeclaration: string = vertexDeclarArr.toString();\r\n\r\n            let subData: PrimitiveSubMesh = new PrimitiveSubMesh();\r\n            subDatas.push(subData);\r\n\r\n            subData.attributeMap = attributeMap;\r\n            subData.boundMax = positionAccessor.max;\r\n            subData.boundMin = positionAccessor.min;\r\n            subData.morphtargets = morphtargets;\r\n            subData.indices = indexArray;\r\n            subData.vertexCount = vertexCount;\r\n            subData.vertexDecler = vertexDeclaration;\r\n            subData.boneIndicesList = boneIndicesList;\r\n            subData.subIndexStartArray = subIndexStartArray;\r\n            subData.subIndexCountArray = subIndexCountArray;\r\n        });\r\n\r\n        this.parseMeshwithSubMeshData(subDatas, layaMesh);\r\n        this.applyglTFSkinData(layaMesh, subDatas, glTFSkin);\r\n        this.applyMorphTarget(layaMesh, subDatas);\r\n        return layaMesh;\r\n    }\r\n\r\n    /**\r\n     * 计算 SkinnedMeshSprite3D local bounds\r\n     * @param skinned \r\n     */\r\n    private calSkinnedSpriteLocalBounds(skinned: SkinnedMeshSprite3D): void {\r\n        let render: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        let mesh: Mesh = skinned.meshFilter.sharedMesh;\r\n        let rootBone: Sprite3D = render.rootBone;\r\n\r\n        let oriRootMatrix: Matrix4x4 = rootBone.transform.worldMatrix;\r\n        let invertRootMatrix: Matrix4x4 = new Matrix4x4();\r\n        oriRootMatrix.invert(invertRootMatrix);\r\n\r\n        let indices = mesh.getIndices();\r\n\r\n        let positions: Vector3[] = [];\r\n        let boneIndices: Vector4[] = [];\r\n        let boneWeights: Vector4[] = [];\r\n        mesh.getPositions(positions);\r\n        mesh.getBoneIndices(boneIndices);\r\n        mesh.getBoneWeights(boneWeights);\r\n\r\n        let oriBoneIndeices: Vector4[] = [];\r\n        mesh._subMeshes.forEach((subMesh: SubMesh, index: number) => {\r\n            let bonelists: Uint16Array[] = subMesh._boneIndicesList;\r\n            bonelists.forEach((bonelist: Uint16Array, listIndex: number) => {\r\n                let start: number = subMesh._subIndexBufferStart[listIndex];\r\n                let count: number = subMesh._subIndexBufferCount[listIndex];\r\n                let endIndex: number = count + start;\r\n                for (let iindex = start; iindex < endIndex; iindex++) {\r\n                    let ii: number = indices[iindex];\r\n                    let boneIndex: Vector4 = boneIndices[ii];\r\n                    let x: number = bonelist[boneIndex.x];\r\n                    let y: number = bonelist[boneIndex.y];\r\n                    let z: number = bonelist[boneIndex.z];\r\n                    let w: number = bonelist[boneIndex.w];\r\n                    oriBoneIndeices[ii] = new Vector4(x, y, z, w);\r\n                }\r\n            });\r\n        });\r\n\r\n        let inverseBindPoses: Matrix4x4[] = mesh._inverseBindPoses;\r\n        let bones: Sprite3D[] = render.bones;\r\n        let ubones: Matrix4x4[] = [];\r\n        let tempMat: Matrix4x4 = new Matrix4x4();\r\n        bones.forEach((bone, index) => {\r\n            ubones[index] = new Matrix4x4();\r\n            Matrix4x4.multiply(invertRootMatrix, bone.transform.worldMatrix, tempMat);\r\n            Matrix4x4.multiply(tempMat, inverseBindPoses[index], ubones[index]);\r\n        });\r\n\r\n        let skinTransform: Matrix4x4 = new Matrix4x4;\r\n        let resPos: Vector3 = new Vector3();\r\n        let min: Vector3 = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);\r\n        let max: Vector3 = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);\r\n\r\n        for (let index = 0; index < positions.length; index++) {\r\n            let pos: Vector3 = positions[index];\r\n            let boneIndex: Vector4 = oriBoneIndeices[index];\r\n            let boneWeight: Vector4 = boneWeights[index];\r\n\r\n            if (!(boneIndex && boneWeight)) {\r\n                continue;\r\n            }\r\n\r\n            for (let ei = 0; ei < 16; ei++) {\r\n                skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n                skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n                skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n                skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n            }\r\n            Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n            Vector3.min(min, resPos, min);\r\n            Vector3.max(max, resPos, max);\r\n\r\n        }\r\n\r\n        // positions.forEach((pos: Vector3, index: number) => {\r\n        //     let boneIndex: Vector4 = oriBoneIndeices[index];\r\n        //     let boneWeight: Vector4 = boneWeights[index];\r\n\r\n        //     for (let ei = 0; ei < 16; ei++) {\r\n        //         skinTransform.elements[ei] = ubones[boneIndex.x].elements[ei] * boneWeight.x;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.y].elements[ei] * boneWeight.y;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.z].elements[ei] * boneWeight.z;\r\n        //         skinTransform.elements[ei] += ubones[boneIndex.w].elements[ei] * boneWeight.w;\r\n        //     }\r\n        //     Vector3.transformV3ToV3(pos, skinTransform, resPos);\r\n        //     Vector3.min(min, resPos, min);\r\n        //     Vector3.max(max, resPos, max);\r\n        // });\r\n\r\n        positions = null;\r\n        boneIndices = boneWeights = oriBoneIndeices = null;\r\n        indices = null;\r\n        ubones = null;\r\n\r\n        render.localBounds.setMin(min);\r\n        render.localBounds.setMax(max);\r\n        render.localBounds = render.localBounds;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 补全 skinnedMeshSprite 所需数据\r\n     * @param glTFNode \r\n     * @param skinned \r\n     */\r\n    private fixSkinnedSprite(glTFNode: glTF.glTFNode, skinned: SkinnedMeshSprite3D): void {\r\n        let skin: glTF.glTFSkin = this._data.skins[glTFNode.skin];\r\n        let skinnedMeshRenderer: SkinnedMeshRenderer = skinned.skinnedMeshRenderer;\r\n        skin.joints.forEach(nodeIndex => {\r\n            let bone: Sprite3D = this._nodes[nodeIndex];\r\n            skinnedMeshRenderer.bones.push(bone);\r\n        });\r\n        if (skin.skeleton == undefined) {\r\n            skin.skeleton = skin.joints[0];\r\n        }\r\n        skinnedMeshRenderer.rootBone = this._nodes[skin.skeleton];\r\n\r\n        this.calSkinnedSpriteLocalBounds(skinned);\r\n    }\r\n\r\n    /**\r\n     * @interna\r\n     * 获取 Animator 根节点\r\n     */\r\n    private getAnimationRoot(channels: glTF.glTFAnimationChannel[]): Sprite3D {\r\n        const isContainNode = (nodeArr: number[], findNodeIndex: number): boolean => {\r\n            if (!nodeArr)\r\n                return false;\r\n            if (nodeArr.indexOf(findNodeIndex) == -1) {\r\n                for (let index = 0; index < nodeArr.length; index++) {\r\n                    let glTFNode: glTF.glTFNode = this._data.nodes[nodeArr[index]];\r\n                    if (isContainNode(glTFNode.children, findNodeIndex)) {\r\n                        return true;\r\n                    }\r\n                }\r\n            }\r\n            return true;\r\n        }\r\n\r\n        let target: glTF.glTFAnimationChannelTarget = channels[0].target;\r\n        let spriteIndex: number = target.node;\r\n        for (let index = 0; index < this._data.scenes.length; index++) {\r\n            let glTFScene: glTF.glTFScene = this._data.scenes[index];\r\n            if (isContainNode(glTFScene.nodes, spriteIndex)) {\r\n                return this._scenes[index];\r\n            }\r\n        }\r\n        return null;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 获取 动画路径信息\r\n     * @param root \r\n     * @param curSprite \r\n     */\r\n    private getAnimationPath(root: Sprite3D, curSprite: Sprite3D): string[] {\r\n        let paths: string[] = [];\r\n        if (root == curSprite)\r\n            return paths;\r\n\r\n        let sprite: Sprite3D = curSprite;\r\n        while (sprite.parent != root) {\r\n            sprite = <Sprite3D>sprite.parent;\r\n            paths.push(sprite.name);\r\n        }\r\n        paths = paths.reverse();\r\n        paths.push(curSprite.name);\r\n        return paths;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animations \r\n     */\r\n    private loadAnimations(animations?: glTF.glTFAnimation[]): void {\r\n        if (!animations)\r\n            return;\r\n\r\n        animations.forEach((animation: glTF.glTFAnimation, index: number) => {\r\n            // todo \r\n            this.loadAnimation(animation);\r\n        });\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 加载 Animation\r\n     * @param animation \r\n     */\r\n    private loadAnimation(animation: glTF.glTFAnimation): Animator {\r\n        // todo extension and extra\r\n\r\n        return this.createAnimator(animation);\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 Animator 组件\r\n     * @param animation \r\n     */\r\n    private createAnimator(animation: glTF.glTFAnimation): Animator {\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let animatorRoot: Sprite3D = this.getAnimationRoot(channels);\r\n\r\n        if (!animatorRoot) {\r\n            return null;\r\n        }\r\n\r\n        let animator: Animator = animatorRoot.getComponent(Animator);\r\n        if (!animator) {\r\n            animator = animatorRoot.addComponent(Animator);\r\n            let animatorLayer: AnimatorControllerLayer = new AnimatorControllerLayer(\"AnimatorLayer\");\r\n            animator.addControllerLayer(animatorLayer);\r\n            animatorLayer.defaultWeight = 1.0;\r\n        }\r\n\r\n        let clip: AnimationClip = this.createAnimatorClip(animation, animatorRoot);\r\n        let animatorLayer: AnimatorControllerLayer = animator.getControllerLayer();\r\n\r\n        let animationName: string = clip.name;\r\n\r\n        if (animatorLayer.getAnimatorState(animationName)) {\r\n            animationName = clip.name = `${animationName}_${this.generateId(animationName)}`;\r\n        }\r\n\r\n        let animatorState: AnimatorState = new AnimatorState();\r\n        // todo  state name\r\n        animatorState.name = animationName;\r\n        animatorState.clip = clip;\r\n        animatorLayer.addState(animatorState);\r\n        animatorLayer.defaultState = animatorState;\r\n        animatorLayer.playOnWake = true;\r\n\r\n        return animator;\r\n    }\r\n\r\n    /**\r\n     * @internal\r\n     * 创建 AnimationClip\r\n     * @param animation \r\n     * @param animatorRoot \r\n     * @returns \r\n     */\r\n    protected createAnimatorClip(animation: glTF.glTFAnimation, animatorRoot: Sprite3D): AnimationClip {\r\n        let clip: AnimationClip = new AnimationClip();\r\n\r\n        let duration: number = 0;\r\n\r\n        let channels: glTF.glTFAnimationChannel[] = animation.channels;\r\n        let samplers: glTF.glTFAnimationSampler[] = animation.samplers;\r\n\r\n        let clipNodes: ClipNode[] = [];\r\n        channels.forEach((channel: glTF.glTFAnimationChannel, index: number) => {\r\n            let target: glTF.glTFAnimationChannelTarget = channel.target;\r\n            let sampler: glTF.glTFAnimationSampler = samplers[channel.sampler];\r\n            let targetPath: glTF.glTFAnimationChannelTargetPath = target.path;\r\n\r\n            let timeBuffer = this.getBufferwithAccessorIndex(sampler.input);\r\n            let outBuffer = this.getBufferwithAccessorIndex(sampler.output);\r\n\r\n            let timeArray = new Float32Array(timeBuffer);\r\n            let outArray = new Float32Array(outBuffer);\r\n\r\n            let sprite: Sprite3D = this._nodes[target.node];\r\n\r\n            let animaPaths = this.getAnimationPath(animatorRoot, sprite);\r\n\r\n            if (targetPath == glTF.glTFAnimationChannelTargetPath.WEIGHTS) {\r\n\r\n                let mesh = sprite.getComponent(MeshFilter)?.sharedMesh;\r\n                if (mesh && mesh.morphTargetData) {\r\n\r\n                    let ownerStr = sprite.getComponent(SkinnedMeshRenderer) ? \"SkinnedMeshRenderer\" : \"MeshRenderer\";\r\n\r\n                    let morphData = mesh.morphTargetData;\r\n                    let channelCount = morphData.channelCount;\r\n                    // check data \r\n                    if (outArray.length / timeArray.length == channelCount) {\r\n                        for (let channelIndex = 0; channelIndex < channelCount; channelIndex++) {\r\n                            let morphChannel = morphData.getMorphChannelbyIndex(channelIndex);\r\n                            let channelName = morphChannel.name;\r\n\r\n                            let clipNode: ClipNode = {};\r\n                            clipNodes.push(clipNode);\r\n                            clipNode.paths = animaPaths;\r\n                            clipNode.interpolation = sampler.interpolation;\r\n                            clipNode.timeArray = timeArray;\r\n                            clipNode.valueArray = new Float32Array(timeArray.length);\r\n                            for (let i = 0; i < timeArray.length; i++) {\r\n                                clipNode.valueArray[i] = outArray[i * channelCount + channelIndex];\r\n                            }\r\n\r\n                            clipNode.propertyOwner = ownerStr;\r\n                            clipNode.propertise = [];\r\n                            clipNode.propertise.push(\"morphTargetValues\");\r\n                            clipNode.propertise.push(channelName);\r\n                            clipNode.propertyLength = clipNode.propertise.length;\r\n                            clipNode.type = 0;\r\n                            clipNode.callbackFunc = \"_changeMorphTargetValue\";\r\n                            clipNode.callbackParams = [channelName];\r\n                            clipNode.propertyChangePath = \"morphTargetValues\";\r\n\r\n                            clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                            duration = Math.max(duration, clipNode.duration);\r\n                        }\r\n                    }\r\n                }\r\n            }\r\n            else {\r\n                let clipNode: ClipNode = {};\r\n                clipNodes.push(clipNode);\r\n                clipNode.timeArray = timeArray;\r\n                clipNode.valueArray = outArray;\r\n                let interpolation = sampler.interpolation;\r\n                clipNode.interpolation = interpolation;\r\n\r\n                clipNode.paths = animaPaths;\r\n\r\n                switch (targetPath) {\r\n                    case glTF.glTFAnimationChannelTargetPath.TRANSLATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localPosition\");\r\n                        clipNode.type = 1;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.ROTATION:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localRotation\");\r\n                        clipNode.type = 2;\r\n                        break;\r\n                    case glTF.glTFAnimationChannelTargetPath.SCALE:\r\n                        clipNode.propertyOwner = \"transform\";\r\n                        clipNode.propertyLength = 1;\r\n                        clipNode.propertise = [];\r\n                        clipNode.propertise.push(\"localScale\");\r\n                        clipNode.type = 3;\r\n                        break;\r\n                    default:\r\n                        break;\r\n                }\r\n\r\n                clipNode.duration = clipNode.timeArray[clipNode.timeArray.length - 1];\r\n                duration = Math.max(duration, clipNode.duration);\r\n            }\r\n        });\r\n\r\n        clip.name = animation.name ? animation.name : `Animation_${this.generateId(\"Animation\")}`;\r\n        clip._duration = duration;\r\n        clip.islooping = true;\r\n        clip._frameRate = 30;\r\n        let nodeCount: number = clipNodes.length;\r\n        let nodes: KeyframeNodeList = clip._nodes;\r\n        nodes.count = nodeCount;\r\n        let nodesMap: any = clip._nodesMap = {};\r\n        let nodesDic: any = clip._nodesDic = {};\r\n        for (let i: number = 0; i < nodeCount; i++) {\r\n            let node: KeyframeNode = new KeyframeNode();\r\n\r\n            let glTFClipNode: ClipNode = clipNodes[i];\r\n\r\n            nodes.setNodeByIndex(i, node);\r\n            node._indexInList = i;\r\n            // todo type\r\n            let type: number = node.type = glTFClipNode.type;\r\n            let pathLength: number = glTFClipNode.paths.length;\r\n            node._setOwnerPathCount(pathLength);\r\n            let tempPath: string[] = glTFClipNode.paths;\r\n            for (let j: number = 0; j < pathLength; j++) {\r\n                node._setOwnerPathByIndex(j, tempPath[j]);\r\n            }\r\n            let nodePath: string = node._joinOwnerPath(\"/\");\r\n            let mapArray: KeyframeNode[] = nodesMap[nodePath];\r\n            (mapArray) || (nodesMap[nodePath] = mapArray = []);\r\n            mapArray.push(node);\r\n            node.propertyOwner = glTFClipNode.propertyOwner;\r\n            let propertyLength: number = glTFClipNode.propertyLength;\r\n            node._setPropertyCount(propertyLength);\r\n            for (let j: number = 0; j < propertyLength; j++) {\r\n                node._setPropertyByIndex(j, glTFClipNode.propertise[j]);\r\n            }\r\n            let fullPath: string = nodePath + \".\" + node.propertyOwner + \".\" + node._joinProperty(\".\");\r\n            nodesDic[fullPath] = fullPath;\r\n            node.fullPath = fullPath;\r\n\r\n            node.callbackFunData = glTFClipNode.callbackFunc;\r\n            node.callParams = glTFClipNode.callbackParams;\r\n            node.propertyChangePath = glTFClipNode.propertyChangePath;\r\n\r\n            let keyframeCount: number = glTFClipNode.timeArray.length;\r\n\r\n            // laya animation version \"LAYAANIMATION:04\"\r\n            for (let j: number = 0; j < keyframeCount; j++) {\r\n                switch (type) {\r\n                    case 0:\r\n                        let floatKeyFrame = new FloatKeyframe();\r\n                        node._setKeyframeByIndex(j, floatKeyFrame);\r\n                        floatKeyFrame.time = glTFClipNode.timeArray[j];\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[3 * j + 1];\r\n                                    // todo\r\n                                    floatKeyFrame.inTangent = glTFClipNode.valueArray[3 * j + 0];\r\n                                    floatKeyFrame.outTangent = glTFClipNode.valueArray[3 * j + 2];\r\n                                }\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n                                floatKeyFrame.inTangent = Infinity;\r\n                                floatKeyFrame.outTangent = Infinity;\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    floatKeyFrame.value = glTFClipNode.valueArray[j];\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastValue = glTFClipNode.valueArray[lastI];\r\n                                    let lastTimeDet = lastI == j ? 1 : (floatKeyFrame.time - lastTime);\r\n\r\n                                    floatKeyFrame.inTangent = (floatKeyFrame.value - lastValue) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextValue = glTFClipNode.valueArray[nextI];\r\n                                    let nextTimeDet = nextI == j ? 1 : (nextTime - floatKeyFrame.time);\r\n\r\n                                    floatKeyFrame.outTangent = (nextValue - floatKeyFrame.value) / nextTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        floatKeyFrame.inTangent = floatKeyFrame.outTangent;\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        floatKeyFrame.outTangent = floatKeyFrame.inTangent;\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n\r\n                        break;\r\n                    case 1: // local position\r\n                    case 3: // local scale\r\n                    case 4: // local euler angler raw\r\n                        let floatArrayKeyframe: Vector3Keyframe = new Vector3Keyframe();\r\n                        node._setKeyframeByIndex(j, floatArrayKeyframe);\r\n                        let startTimev3: number = floatArrayKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangent: Vector3 = floatArrayKeyframe.inTangent;\r\n                        let outTangent: Vector3 = floatArrayKeyframe.outTangent;\r\n                        let value: Vector3 = floatArrayKeyframe.value;\r\n\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                value.setValue(glTFClipNode.valueArray[9 * j + 3], glTFClipNode.valueArray[9 * j + 4], glTFClipNode.valueArray[9 * j + 5]);\r\n                                inTangent.setValue(glTFClipNode.valueArray[9 * j + 0], glTFClipNode.valueArray[9 * j + 1], glTFClipNode.valueArray[9 * j + 2]);\r\n                                outTangent.setValue(glTFClipNode.valueArray[9 * j + 6], glTFClipNode.valueArray[9 * j + 7], glTFClipNode.valueArray[9 * j + 8]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n                                inTangent.setValue(Infinity, Infinity, Infinity);\r\n                                outTangent.setValue(Infinity, Infinity, Infinity);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    value.setValue(glTFClipNode.valueArray[3 * j], glTFClipNode.valueArray[3 * j + 1], glTFClipNode.valueArray[3 * j + 2]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[3 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[3 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[3 * lastI + 2];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimev3 - lastTime;\r\n                                    inTangent.x = (value.x - lastX) / lastTimeDet;\r\n                                    inTangent.y = (value.y - lastY) / lastTimeDet;\r\n                                    inTangent.z = (value.z - lastZ) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[3 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[3 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[3 * nextI + 2];\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimev3;\r\n                                    outTangent.x = (nextX - value.x) / nestTimeDet;\r\n                                    outTangent.y = (nextY - value.y) / nestTimeDet;\r\n                                    outTangent.z = (nextZ - value.z) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangent.cloneTo(inTangent);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangent.cloneTo(outTangent);\r\n                                    }\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                    case 2: // local rotation\r\n                        let quaternionKeyframe: QuaternionKeyframe = new QuaternionKeyframe();\r\n                        node._setKeyframeByIndex(j, quaternionKeyframe);\r\n                        let startTimeQu: number = quaternionKeyframe.time = glTFClipNode.timeArray[j];\r\n                        let inTangentQua: Vector4 = quaternionKeyframe.inTangent;\r\n                        let outTangentQua: Vector4 = quaternionKeyframe.outTangent;\r\n                        let valueQua: Quaternion = quaternionKeyframe.value;\r\n                        switch (glTFClipNode.interpolation) {\r\n                            case glTF.glTFAnimationSamplerInterpolation.CUBICSPLINE:\r\n                                valueQua.set(glTFClipNode.valueArray[12 * j + 4], glTFClipNode.valueArray[12 * j + 5], glTFClipNode.valueArray[12 * j + 6], glTFClipNode.valueArray[12 * j + 7]);\r\n                                inTangentQua.setValue(glTFClipNode.valueArray[12 * j + 0], glTFClipNode.valueArray[12 * j + 1], glTFClipNode.valueArray[12 * j + 2], glTFClipNode.valueArray[12 * j + 3]);\r\n                                outTangentQua.setValue(glTFClipNode.valueArray[12 * j + 8], glTFClipNode.valueArray[12 * j + 9], glTFClipNode.valueArray[12 * j + 10], glTFClipNode.valueArray[12 * j + 11]);\r\n                                break;\r\n                            case glTF.glTFAnimationSamplerInterpolation.STEP:\r\n                                valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n                                inTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                outTangentQua.setValue(Infinity, Infinity, Infinity, Infinity);\r\n                                break;\r\n\r\n                            case glTF.glTFAnimationSamplerInterpolation.LINEAR:\r\n                            default:\r\n                                {\r\n                                    valueQua.set(glTFClipNode.valueArray[4 * j + 0], glTFClipNode.valueArray[4 * j + 1], glTFClipNode.valueArray[4 * j + 2], glTFClipNode.valueArray[4 * j + 3]);\r\n\r\n                                    let lastI = j == 0 ? j : j - 1;\r\n                                    let lastTime = glTFClipNode.timeArray[lastI];\r\n                                    let lastX = glTFClipNode.valueArray[4 * lastI];\r\n                                    let lastY = glTFClipNode.valueArray[4 * lastI + 1];\r\n                                    let lastZ = glTFClipNode.valueArray[4 * lastI + 2];\r\n                                    let lastW = glTFClipNode.valueArray[4 * lastI + 3];\r\n\r\n                                    let lastTimeDet = lastI == j ? 1 : startTimeQu - lastTime;\r\n                                    inTangentQua.x = (valueQua.x - lastX) / lastTimeDet;\r\n                                    inTangentQua.y = (valueQua.y - lastY) / lastTimeDet;\r\n                                    inTangentQua.z = (valueQua.z - lastZ) / lastTimeDet;\r\n                                    inTangentQua.w = (valueQua.w - lastW) / lastTimeDet;\r\n\r\n                                    let nextI = j == keyframeCount - 1 ? j : j + 1;\r\n                                    let nextTime = glTFClipNode.timeArray[nextI];\r\n                                    let nextX = glTFClipNode.valueArray[4 * nextI];\r\n                                    let nextY = glTFClipNode.valueArray[4 * nextI + 1];\r\n                                    let nextZ = glTFClipNode.valueArray[4 * nextI + 2];\r\n                                    let nextW = glTFClipNode.valueArray[4 * nextI + 3];\r\n\r\n                                    if ((valueQua.x * nextX + valueQua.y * nextY + valueQua.z * nextZ + valueQua.w * nextW) < 0) {\r\n                                        nextX *= -1;\r\n                                        nextY *= -1;\r\n                                        nextZ *= -1;\r\n                                        nextW *= -1;\r\n                                        glTFClipNode.valueArray[4 * nextI] = nextX;\r\n                                        glTFClipNode.valueArray[4 * nextI + 1] = nextY;\r\n                                        glTFClipNode.valueArray[4 * nextI + 2] = nextZ;\r\n                                        glTFClipNode.valueArray[4 * nextI + 3] = nextW;\r\n                                    }\r\n\r\n                                    let nestTimeDet = nextI == j ? 1 : nextTime - startTimeQu;\r\n                                    outTangentQua.x = (nextX - valueQua.x) / nestTimeDet;\r\n                                    outTangentQua.y = (nextY - valueQua.y) / nestTimeDet;\r\n                                    outTangentQua.z = (nextZ - valueQua.z) / nestTimeDet;\r\n                                    outTangentQua.w = (nextW - valueQua.w) / nestTimeDet;\r\n\r\n                                    if (lastI == j) {\r\n                                        outTangentQua.cloneTo(inTangentQua);\r\n                                    }\r\n                                    if (nextI == j) {\r\n                                        inTangentQua.cloneTo(outTangentQua);\r\n                                    }\r\n\r\n                                }\r\n                                break;\r\n                        }\r\n                        break;\r\n                }\r\n            }\r\n        }\r\n\r\n        clipNodes = null;\r\n\r\n        return clip;\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 sub morph data 所需数据\r\n */\r\nclass SubMorphData {\r\n    weights: number[];\r\n    position: boolean;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    normal: boolean;\r\n    tangent: boolean;\r\n    targets: { [name: string]: Map<string, Float32Array> }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 submesh 所需数据\r\n */\r\nclass PrimitiveSubMesh {\r\n\r\n    attributeMap: Map<string, Float32Array>;\r\n    boundMin: number[];\r\n    boundMax: number[];\r\n    indices: Uint32Array;\r\n    vertexDecler: string;\r\n    vertexCount: number;\r\n    boneIndicesList: Uint16Array[];\r\n    subIndexStartArray: number[];\r\n    subIndexCountArray: number[];\r\n\r\n    morphtargets: SubMorphData;\r\n\r\n    constructor() {\r\n\r\n    }\r\n}\r\n\r\n/**\r\n * @internal\r\n * 辅助记录 animator clip 所需数据\r\n */\r\ninterface ClipNode {\r\n    paths?: string[];\r\n    propertyOwner?: string;\r\n    propertyLength?: number;\r\n    propertise?: string[];\r\n    timeArray?: Float32Array;\r\n    valueArray?: Float32Array;\r\n    interpolation?: glTF.glTFAnimationSamplerInterpolation;\r\n    duration?: number;\r\n    type?: number;\r\n    callbackFunc?: string;\r\n    callbackParams?: any[];\r\n    propertyChangePath?: string;\r\n}\r\n\r\nLaya.onInitModule(() => {\r\n    glTFShader.init();\r\n});\r\n","import { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\n\r\nconst ExtensionName = \"KHR_materials_anisotropy\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialAnisotropy {\r\n        /** The anisotropy strength. When anisotropyTexture is present, this value is multiplied by the blue channel. default: 0.0 */\r\n        anisotropyStrength: number;\r\n        /** The rotation of the anisotropy in tangent, bitangent space, measured in radians counter-clockwise from the tangent. When anisotropyTexture is present, anisotropyRotation provides additional rotation to the vectors in the texture. default: 0.0 */\r\n        anisotropyRotation: number;\r\n        /** The anisotropy texture. Red and green channels represent the anisotropy direction in [-1, 1] tangent, bitangent space, to be rotated by anisotropyRotation. The blue channel contains strength as [0, 1] to be multiplied by anisotropyStrength. */\r\n        anisotropyTexture: glTFTextureInfo;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_anisotropy implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialAnisotropy = material.extensions?.KHR_materials_anisotropy;\r\n                if (extension) {\r\n                    if (extension.anisotropyTexture) {\r\n                        let index = extension.anisotropyTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialAnisotropy = glTFMaterial.extensions.KHR_materials_anisotropy;\r\n\r\n        let anisotropy = extension.anisotropyStrength ?? 0.0;\r\n        let rotation = extension.anisotropyRotation ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_ANISOTROPY, true);\r\n        material.setFloat(\"u_AnisotropyStrength\", anisotropy);\r\n        material.setFloat(\"u_AnisotropyRotation\", rotation);\r\n\r\n        if (extension.anisotropyTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.anisotropyTexture);\r\n            material.setTexture(\"u_AnisotropyTexture\", tex);\r\n            material.setDefine(glTFShader.Define_AnisotropyMap, true);\r\n        }\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_anisotropy(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { PBRMaterial } from \"../../d3/core/material/PBRMaterial\";\r\nimport { PBRShaderLib } from \"../../d3/shader/pbr/PBRShaderLib\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { Texture2D } from \"../../resource/Texture2D\";\r\nimport * as glTF from \"../glTFInterface\";\r\n\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { glTFShader } from \"../shader/glTFShader\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nconst ExtensionName = \"KHR_materials_clearcoat\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialClearCoat {\r\n        /** The clearcoat layer intensity. default: 0.0*/\r\n        clearcoatFactor?: number;\r\n        /** The base color texture */\r\n        clearcoatTexture?: glTFTextureInfo;\r\n        /** The clearcoat layer roughness.  default: 0.0*/\r\n        clearcoatRoughnessFactor?: number;\r\n        /** The clearcoat layer roughness texture.*/\r\n        clearcoatRoughnessTexture?: glTFTextureInfo;\r\n        /** The clearcoat normal map texture. */\r\n        clearcoatNormalTexture?: glTFMaterialNormalTextureInfo;\r\n    }\r\n\r\n}\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_materials_clearcoat\r\n * \r\n * exclusions: KHR_materials_pbrSpecularGlossiness, KHR_materials_unlit\r\n */\r\nexport class KHR_materials_clearcoat implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    loadTextures(basePath: string, progress?: IBatchProgress): Promise<any> {\r\n        let materials = this._resource.data.materials;\r\n        let textures = this._resource.data.textures;\r\n\r\n        if (materials && textures) {\r\n            let promises: Array<Promise<Texture2D>> = [];\r\n            materials.forEach(material => {\r\n                let extension: glTF.glTFMaterialClearCoat = material.extensions?.KHR_materials_clearcoat;\r\n                if (extension) {\r\n                    if (extension.clearcoatTexture) {\r\n                        let index = extension.clearcoatTexture.index\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatRoughnessTexture) {\r\n                        let index = extension.clearcoatRoughnessTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                    if (extension.clearcoatNormalTexture) {\r\n                        let index = extension.clearcoatNormalTexture.index;\r\n                        let promise = this._resource.loadTextureFromglTF(index, false, basePath, progress);\r\n                        promises.push(promise);\r\n                    }\r\n                }\r\n            });\r\n            return Promise.all(promises);\r\n        }\r\n        else {\r\n            return Promise.resolve();\r\n        }\r\n    }\r\n\r\n    additionMaterialProperties(glTFMaterial: glTF.glTFMaterial, material: Material): void {\r\n        let extension: glTF.glTFMaterialClearCoat = glTFMaterial.extensions.KHR_materials_clearcoat;\r\n        let clearCoat = extension.clearcoatFactor ?? 0.0;\r\n        let clearCoatRoughness = extension.clearcoatRoughnessFactor ?? 0.0;\r\n\r\n        material.setDefine(PBRShaderLib.DEFINE_CLEARCOAT, true);\r\n\r\n        material.setFloat(\"u_ClearCoatFactor\", clearCoat);\r\n        if (extension.clearcoatTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatTexture);\r\n            material.setTexture(\"u_ClearCoatTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatMap, true)\r\n        }\r\n\r\n        material.setFloat(\"u_ClearCoatRoughness\", clearCoatRoughness);\r\n        if (extension.clearcoatRoughnessTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatRoughnessTexture);\r\n            material.setTexture(\"u_ClearCoatRoughnessTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatRoughnessMap, true);\r\n        }\r\n\r\n        if (extension.clearcoatNormalTexture) {\r\n            let tex = this._resource.getTextureWithInfo(extension.clearcoatNormalTexture);\r\n            material.setTexture(\"u_ClearCoatNormalTexture\", tex);\r\n            material.setDefine(glTFShader.Define_ClearCoatNormalMap, true);\r\n            let scale = extension.clearcoatNormalTexture.scale ?? 1.0;\r\n            material.setFloat(\"u_ClearCoatNormalScale\", scale);\r\n        }\r\n    }\r\n\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_clearcoat(resource));","import { Material } from \"../../d3/core/material/Material\";\r\nimport { IBatchProgress } from \"../../net/BatchProgress\";\r\nimport { glTFMaterial } from \"../glTFInterface\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\n\r\nimport * as glTF from \"../glTFInterface\";\r\nimport { glTFResource } from \"../glTFResource\";\r\nimport { PBRStandardMaterial } from \"../../d3/core/material/PBRStandardMaterial\";\r\n\r\nconst ExtensionName = \"KHR_materials_emissive_strength\";\r\n\r\ndeclare module \"../glTFInterface\" {\r\n\r\n    export interface glTFMaterialEmissionStrength {\r\n        /** The strength adjustment to be multiplied with the material's emissive value. default: 1.0 */\r\n        emissiveStrength: number;\r\n    }\r\n\r\n}\r\n\r\nexport class KHR_materials_emissive_strength implements glTFExtension {\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    additionMaterialProperties?(glTFMaterial: glTFMaterial, material: Material): void {\r\n\r\n        let extension: glTF.glTFMaterialEmissionStrength = glTFMaterial.extensions.KHR_materials_emissive_strength;\r\n\r\n        let emissionStrength = extension.emissiveStrength ?? 1.0;\r\n\r\n        material.setFloat(\"u_EmissionStrength\", emissionStrength);\r\n    }\r\n\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_emissive_strength(resource));","import * as glTF from \"../glTFInterface\";\r\n\r\nimport { Material } from \"../../d3/core/material/Material\";\r\nimport { glTFExtension } from \"./glTFExtension\";\r\nimport { UnlitMaterial } from \"../../d3/core/material/UnlitMaterial\";\r\nimport { glTFResource } from \"../glTFResource\";\r\n\r\nconst ExtensionName = \"KHR_materials_unlit\";\r\n\r\n/**\r\n * @internal\r\n * https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Khronos/KHR_materials_unlit/README.md\r\n */\r\nexport class KHR_materials_unlit implements glTFExtension {\r\n\r\n    readonly name: string = ExtensionName;\r\n\r\n    private _resource: glTFResource;\r\n\r\n    constructor(resource: glTFResource) {\r\n        this._resource = resource;\r\n    }\r\n\r\n    createMaterial(glTFMaterial: glTF.glTFMaterial): Material {\r\n        let unlit = new UnlitMaterial();\r\n\r\n        let pbrMetallicRoughness = glTFMaterial.pbrMetallicRoughness;\r\n        if (pbrMetallicRoughness) {\r\n            if (pbrMetallicRoughness.baseColorFactor) {\r\n                let color = unlit.albedoColor;\r\n                color.fromArray(pbrMetallicRoughness.baseColorFactor);\r\n                color.toGamma(color);\r\n                unlit.albedoColor = color;\r\n            }\r\n\r\n            if (pbrMetallicRoughness.baseColorTexture) {\r\n                unlit.albedoTexture = this._resource.getTextureWithInfo(pbrMetallicRoughness.baseColorTexture);\r\n            }\r\n        }\r\n\r\n        this._resource.applyMaterialRenderState(glTFMaterial, unlit);\r\n\r\n        return unlit;\r\n    }\r\n}\r\n\r\nglTFResource.registerExtension(ExtensionName, (resource) => new KHR_materials_unlit(resource));\r\n","import { ILoadTask, IResourceLoader, Loader } from \"../net/Loader\";\r\nimport * as glTF from \"./glTFInterface\";\r\nimport { glTFResource } from \"./glTFResource\";\r\n\r\nimport \"./extensions/KHR_materials_anisotropy\";\r\nimport \"./extensions/KHR_materials_clearcoat\";\r\nimport \"./extensions/KHR_materials_emissive_strength\";\r\nimport \"./extensions/KHR_materials_unlit\";\r\n\r\nclass glTFLoader implements IResourceLoader {\r\n    load(task: ILoadTask) {\r\n        return task.loader.fetch(task.url, \"json\", task.progress.createCallback(0.5), task.options).then((data: glTF.glTF) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parse(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"gltf\"], glTFLoader);\r\n\r\nclass glbLoader implements IResourceLoader {\r\n    load(task: ILoadTask): Promise<any> {\r\n        return task.loader.fetch(task.url, \"arraybuffer\", task.progress.createCallback(0.5), task.options).then((data: ArrayBuffer) => {\r\n            let glTF = new glTFResource();\r\n            return glTF._parseglb(data, task.url, task.progress).then(() => glTF);\r\n        });\r\n    }\r\n}\r\n\r\nLoader.registerLoader([\"glb\"], glbLoader);\r\n"],"mappings":"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"}